<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="monetag" content="2dc4448d78fbcf7944504727860de63e">
    <title>Live Payout - Tu Plataforma de Streaming</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="icon" type="image/jpeg" href="https://i.postimg.cc/4xL1nYWJ/android-chrome-512x512.png">
    <link rel="manifest" href="/site.webmanifest">
    <!-- Librerías de Solana añadidas para la nueva lógica de depósito -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
    <script src="https://unpkg.com/@solana/spl-token@latest/lib/index.iife.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>

    <style>
        :root {
            --brand-color-1: #4ade80; /* green */
            --brand-color-2: #3b82f6; /* blue */
            --brand-color-purple: #8347dd;
            --brand-color-purple-dark: #8347dd;
            --background-primary: #0D0D10;
            --background-secondary: #141418;
            --background-tertiary: #1E1E24;
            --border-color: #2a2a32;
            --text-primary: #EAEAEA;
            --text-secondary: #A0A0B0;
        }
        html.dark {
            color-scheme: dark;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-primary);
            color: var(--text-primary);
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--background-secondary); }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        
        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        .animate-slide-in { animation: slideIn 0.5s cubic-bezier(0.25, 1, 0.5, 1); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .brand-gradient-text {
            background: linear-gradient(90deg, var(--brand-color-purple-dark), var(--brand-color-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .purple-gradient-bg {
             background: linear-gradient(90deg, var(--brand-color-purple-dark), var(--brand-color-purple));
        }
        .btn-glow {
            box-shadow: 0 0 5px var(--brand-color-purple), 0 0 10px var(--brand-color-purple);
        }
        .nav-link.active {
            background-color: var(--background-tertiary);
            color: white;
            font-weight: 600;
        }
        .nav-link.active i {
            color: var(--brand-color-purple);
        }
        video {
            width: 100%;
            background-color: black;
            border-radius: 0.75rem;
        }
        .member-badge {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            margin-right: 0.25rem;
            vertical-align: text-bottom;
        }
        .super-chat {
            background: linear-gradient(45deg, #1e3a8a, #4c1d95);
            border: 1px solid #3b82f6;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
        }
        
        /* Estilos para el modal de moderación */
        #mod-modal {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        #mod-modal-content {
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* --- ESTILOS NUEVOS: Carrusel Cover Flow --- */
        .cover-carousel-container {
            position: relative;
            width: 100%;
            margin-bottom: 2rem;
        }
        .cover-carousel {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE */
        }
        .cover-carousel::-webkit-scrollbar { display: none; }
        
        .cover-carousel-item {
            flex: 0 0 90%; /* En móvil, 90% del ancho */
            scroll-snap-align: center;
            margin: 0 0.5rem;
            opacity: 0.5;
            transform: scale(0.9);
            transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .cover-carousel-item-inner {
            background-color: var(--background-secondary);
            border-radius: 0.75rem;
            overflow: hidden;
            border: 1px solid var(--border-color);
            transition: border-color 0.3s;
        }

        /* Centrado y grande */
        .cover-carousel-item.is-snapped {
            opacity: 1;
            transform: scale(1);
        }
        .cover-carousel-item.is-snapped .cover-carousel-item-inner {
             border-color: var(--brand-color-purple);
        }
        
        @media (min-width: 768px) {
            .cover-carousel-item {
                flex-basis: 60%; /* En PC, 60% del ancho */
                margin: 0 1rem;
            }
        }

        .carousel-fade {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 40px;
            pointer-events: none;
            z-index: 2;
        }
        .carousel-fade-left {
            left: 0;
            background: linear-gradient(to right, var(--background-primary), transparent);
        }
        .carousel-fade-right {
            right: 0;
            background: linear-gradient(to left, var(--background-primary), transparent);
        }
        .carousel-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 3;
            background-color: rgba(0,0,0,0.5);
            border-radius: 50%;
            padding: 0.5rem;
            color: white;
            display: none; /* Oculto por defecto, se muestra en PC */
        }
        @media (min-width: 768px) {
            .carousel-nav-btn { display: block; }
        }
        .carousel-nav-btn:hover { background-color: rgba(0,0,0,0.8); }
        .carousel-nav-btn.prev { left: 0.5rem; }
        .carousel-nav-btn.next { right: 0.5rem; }
        
        /* --- ESTILOS NUEVOS: Cuadrícula de 2 columnas en móvil --- */
        .streams-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 columnas en móvil */
            gap: 1rem; /* Espacio reducido para móvil */
        }
        @media (min-width: 640px) {
            .streams-grid {
                grid-template-columns: repeat(2, 1fr); /* 2 columnas en sm */
            }
        }
        @media (min-width: 768px) {
            .streams-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columnas en md */
                gap: 1.5rem;
            }
        }
        @media (min-width: 1024px) {
            .streams-grid {
                grid-template-columns: repeat(4, 1fr); /* 4 columnas en lg */
            }
        }
        @media (min-width: 1280px) {
            .streams-grid {
                grid-template-columns: repeat(5, 1fr); /* 5 columnas en xl */
            }
        }

        /* Tarjeta de stream más pequeña para la cuadrícula */
        .stream-card-small .thumbnail {
            width: 100%;
            aspect-ratio: 16 / 9; /* Imagen más pequeña */
            object-fit: cover;
        }
         .stream-card-small .card-content {
            padding: 0.75rem; /* Menos padding */
         }
         .stream-card-small .streamer-pic {
             width: 2rem; /* Avatar más pequeño */
             height: 2rem;
         }
         .stream-card-small .card-title {
             font-size: 0.875rem; /* Texto más pequeño */
         }
         .stream-card-small .card-info {
             font-size: 0.75rem; /* Texto más pequeño */
         }
         .stream-card-small .card-category {
             font-size: 0.65rem; /* Texto más pequeño */
             padding: 0.125rem 0.375rem;
         }
        
    </style>
</head>
<body class="overflow-y-auto">

    <div id="sidebar-backdrop" class="fixed inset-0 bg-black/50 z-30 hidden md:hidden"></div>

    <div id="app-container" class="h-screen w-screen flex flex-col transition-opacity duration-500 opacity-0">

        <header class="bg-gradient-to-b from-[#18181c] to-[var(--background-secondary)] h-16 flex items-center justify-between px-4 md:px-6 border-b border-[var(--border-color)] z-20 flex-shrink-0">
            <div class="flex items-center gap-4">
                <button id="back-button" class="hidden p-2 -ml-2 rounded-md text-[var(--text-secondary)] hover:bg-[var(--background-tertiary)] md:hidden">
                    <i data-lucide="arrow-left"></i>
                </button>
                <button id="mobile-menu-btn" class="md:hidden p-2 -ml-2 rounded-md text-[var(--text-secondary)] hover:bg-[var(--background-tertiary)]">
                    <i data-lucide="menu" id="mobile-menu-icon"></i>
                </button>
                <a href="#" class="flex items-center nav-action" data-target="explore">
                    <img src="https://i.postimg.cc/50KvH8vD/log-peque.png" alt="Live Payout Logo" class="w-10 h-10 rounded-full">
                </a>
                <button id="desktop-toggle-sidebar" class="hidden md:block p-2 rounded-md text-[var(--text-secondary)] hover:bg-[var(--background-tertiary)]">
                    <i data-lucide="sidebar-open" id="desktop-toggle-icon"></i>
                </button>
                <div class="hidden md:flex items-center gap-2 text-[var(--text-secondary)]">
                    <a href="#" class="nav-link nav-action px-3 py-2 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-all flex items-center gap-2" data-target="explore" data-key="explore"><i data-lucide="compass"></i><span>Explore</span></a>
                    <a href="#" class="nav-link nav-action px-3 py-2 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-all flex items-center gap-2" data-target="categories" data-key="categories"><i data-lucide="layout-grid"></i><span>Categories</span></a>
                </div>
            </div>
            <div id="user-profile-area" class="flex items-center gap-2 md:gap-4">
                <!-- Se rellena dinámicamente -->
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <aside id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-[var(--background-secondary)] flex flex-col z-40 transform -translate-x-full transition-all duration-300 md:relative md:translate-x-0 md:border-r md:border-[var(--border-color)] md:flex-shrink-0">
                <div class="p-4 border-b border-[var(--border-color)] md:hidden">
                    <a href="#" class="flex items-center gap-2 nav-action" data-target="explore">
                        <img src="https://i.postimg.cc/50KvH8vD/log-peque.png" alt="Live Payout Logo" class="w-8 h-8 rounded-full">
                        <span class="font-bold text-lg sidebar-text">Live Payout</span>
                    </a>
                </div>
                <nav class="flex flex-col space-y-2 p-4 md:p-4"> <!-- Ajustado padding de md:p-0 a md:p-4 -->
                    <div class="md:hidden">
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-colors" data-target="explore" data-key="explore"><i data-lucide="compass" class="w-5 h-5"></i><span class="sidebar-text">Explore</span></a>
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-colors" data-target="categories" data-key="categories"><i data-lucide="layout-grid" class="w-5 h-5"></i><span class="sidebar-text">Categories</span></a>
                        <div class="my-2 border-t border-[var(--border-color)]"></div>
                    </div>
                    <div id="creator-section">
                        <h3 class="px-3 text-sm font-semibold text-[var(--text-secondary)] uppercase tracking-wider sidebar-text" data-key="creator">Creator</h3>
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-4 py-3 rounded-xl transition-all duration-300 bg-[var(--background-tertiary)] border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] hover:shadow-[0_0_15px_rgba(167,139,250,0.4)]" data-target="studio">
                            <img src='https://i.postimg.cc/PxTt1gVn/7219b8450aa254b2d47645e0660295c1-icono-o-logotipo-de-camara-de-video.png' class='w-5 h-5 flex-shrink-0' alt='Creator Studio Icon'>
                            <span class="sidebar-text" data-key="creator_studio">Creator Studio</span>
                        </a>
                    </div>
                </nav>
                <div class="my-4 border-t border-[var(--border-color)]"></div>
                <div class="px-4 flex-1 overflow-y-auto">
                  <h3 class="px-3 text-sm font-semibold text-[var(--text-secondary)] uppercase tracking-wider mb-2 sidebar-text" data-key="recommended_channels">Recommended Channels</h3>
                  <div id="recommended-channels" class="space-y-3">
                      <!-- Canales recomendados se cargan aquí -->
                  </div>
                </div>
            </aside>

            <main id="main-content" class="flex-1 bg-[var(--background-primary)] flex flex-col overflow-y-auto p-4 md:p-8">
                <!-- Contenido por defecto: Explorar -->
            </main>
        </div>
    </div>

    <div id="login-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in hidden">
        <div class="bg-[var(--background-secondary)] p-8 rounded-2xl shadow-2xl w-full max-w-md border border-[var(--border-color)] text-center transform transition-all duration-300 scale-95">
            <img src="https://i.postimg.cc/d1N7CQs2/photo-2025-09-19-11-13-33-2.jpg" alt="Logo" class="w-24 h-24 rounded-full mx-auto mb-4">
            <h1 class="text-4xl font-extrabold mb-4">
                <span data-key="welcome_to">Welcome to</span> 
                <span style="color: var(--brand-color-purple);">Live</span><span class="text-white">Payout</span>
            </h1>
            <p class="text-[var(--text-secondary)] mb-8" data-key="login_prompt">Enter with your public Solana wallet address to start.</p>
            <form id="login-form" class="space-y-4">
                <input type="text" id="wallet-address" placeholder="Ej: 5x...yZ" class="w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-1)] transition-all">
                <button type="submit" class="w-full purple-gradient-bg text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg hover:btn-glow" data-key="login_button">
                    Enter / Create Account
                </button>
            </form>
            <p id="login-error" class="text-red-500 mt-4 text-sm h-5"></p>
        </div>
    </div>

    <div id="loader" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100] hidden">
        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-[var(--brand-color-purple)]"></div>
    </div>
    
    <div id="toast" class="fixed bottom-8 right-8 bg-green-600 text-white py-3 px-6 rounded-lg shadow-xl transform translate-y-20 opacity-0 transition-all duration-500 z-[100]">
        <p id="toast-message"></p>
    </div>

    <div id="ad-container" class="fixed inset-0 bg-black/90 z-[200] flex flex-col items-center justify-center text-white text-2xl hidden">
        <p id="ad-warning" class="mb-4 text-center font-bold"></p>
        <div id="ad-slot" class="w-full max-w-lg h-auto flex items-center justify-center"></div>
    </div>
    
    <!-- Modal de Moderación (inicialmente oculto) -->
    <div id="mod-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-[101] hidden opacity-0 scale-95" role="dialog" aria-modal="true" aria-labelledby="mod-modal-title">
        <div id="mod-modal-content" class="bg-[var(--background-secondary)] p-6 rounded-2xl shadow-2xl w-full max-w-sm border border-[var(--border-color)] transform scale-100">
            <h2 id="mod-modal-title" class="text-xl font-bold mb-2">Moderar Usuario</h2>
            <p class="text-[var(--text-secondary)] mb-4" id="mod-modal-username">Vas a moderar a...</p>
            <div class="grid grid-cols-2 gap-3">
                <button class="mod-action-btn bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-lg" data-duration="5">Ban 5 Min</button>
                <button class="mod-action-btn bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-lg" data-duration="10">Ban 10 Min</button>
                <button class="mod-action-btn bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-lg" data-duration="60">Ban 1 Hora</button>
                <button class="mod-action-btn bg-red-700 hover:bg-red-600 text-white p-2 rounded-lg" data-duration="perma">Ban Permanente</button>
            </div>
            <button id="mod-modal-cancel" class="mt-4 w-full bg-gray-500 hover:bg-gray-400 text-white p-2 rounded-lg">Cancelar</button>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, updateDoc, increment, deleteDoc, getDocs, query, where, writeBatch, orderBy, limit, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyACz8EaihKTwAQHAnNCZJ-k8WxF1BDUOGs",
            authDomain: "livep-d622a.firebaseapp.com",
            projectId: "livep-d622a",
            storageBucket: "livep-d622a.firebasestorage.app",
            messagingSenderId: "257830156699",
            appId: "1:257830156699:web:30f1b92479ea035d4ac93e",
            measurementId: "G-EHBX5PD4G4"
        };
        
        const CATEGORIES = ['Just Chatting', 'Crypto Raiders', 'Axie Infinity', 'Star Atlas', 'Decentraland', 'The Sandbox', 'Gods Unchained', 'Music', 'Gaming', 'DeFi'];
        const CATEGORY_IMAGES = {
            'Just Chatting': 'https://i.scdn.co/image/ab6765630000ba8a1b9084981ea8acabb928955b', 'Crypto Raiders': 'https://assets.gam3s.gg/crypto_raiders_cover_3156b1065c/crypto_raiders_cover_3156b1065c.png', 'Axie Infinity': 'https://cdn.axieinfinity.com/axieinfinity-website/branding/axie-infinity-logo.png', 'Star Atlas': 'https://s2.coinmarketcap.com/static/img/coins/200x200/11212.png', 'Decentraland': 'https://www.shutterstock.com/image-vector/vector-image-crypto-currency-logo-600nw-2109327635.jpg', 'The Sandbox': 'https://altcoinsbox.com/wp-content/uploads/2023/03/full-the-sandbox-logo.webp', 'Gods Unchained': 'https://cdn1.epicgames.com/spt-assets/0668c386b36843ee816eccaa027005a8/gods-unchained-1cime.jpg', 'Music': 'https://png.pngtree.com/element_our/sm/20180415/sm_5ad31d9b53530.jpg', 'Gaming': 'https://img.freepik.com/vector-gratis/plantilla-logotipo-juegos-degradados_52683-132733.jpg?semt=ais_incoming&w=740&q=80', 'DeFi': 'https://images-platform.99static.com/DVhnqMGIzJRSQ_Jm4MxWYDGEVYg=/178x53:1458x1333/500x500/top/smart/99designs-contests-attachments/129/129813/attachment_129813968'
        };
        const VIP_EMOJIS = [
            { id: 'penguinsip', url: 'https://i.postimg.cc/DwVTxSBC/40196-penguinsip.gif', price: 20 }, { id: 'pinguin', url: 'https://i.postimg.cc/VLmTvXZP/45541-pinguin.gif', price: 20 }, { id: 'minecraft', url: 'https://i.postimg.cc/Lss1xyx3/403691-minecraft.png', price: 25 }, { id: 'pengubitcoin', url: 'https://i.postimg.cc/tCBrgwVF/42410-pengubitcoin.gif', price: 30 }, { id: 'smart_vegeta', url: 'https://i.postimg.cc/FH2Vd4Fk/793771-smart-vegeta.png', price: 30 }, { id: 'mewgrey', url: 'https://i.postimg.cc/jjWjWB8m/44097-mewgrey.gif', price: 35 }, { id: 'peperain', url: 'https://i.postimg.cc/85CcTF8R/93659-pepemoneyrain.gif', price: 40 }, { id: 'pepemonster', url: 'https://i.postimg.cc/P5z5ZbTb/345529-pepemonster.png', price: 40 }, { id: 'star', url: 'https://i.postimg.cc/fTwT7V2x/990874-star.gif', price: 45 }, { id: 'pepecard', url: 'https://i.postimg.cc/ryr0sr0j/761219-pepe-credit-card.gif', price: 50 }, { id: 'pepecry', url: 'https://i.postimg.cc/sXZXMkXx/471114-pepecry.png', price: 50 }, { id: 'pepesipspin', url: 'https://i.postimg.cc/T2QX6C0D/75754-pepesipspin.gif', price: 55 }
        ];
        const REWARD_INTERVAL_MINUTES = 5;
        const REWARD_AMOUNT = 3000;
        const WITHDRAWAL_MINIMUM_BIT = 1000000;
        const BIT_COIN_LOGO_URL = "https://images.pump.fun/coin-image/EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump?variant=600x600&ipfs=bafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre&src=https%3A%F%2Fipfs.io%2Fipfs%2Fbafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre";

        let app, auth, db;
        let currentUser = null;
        let unsubscribeUser = null;
        let currentLang = 'en';
        let currentPageRender = () => renderExplorePage();
        let navigationHistory = [];
        
        let modModalTargetUser = { wallet: null, name: null };
        let carouselInterval = null;


        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        
        const loginModal = document.getElementById('login-modal');
        const appContainer = document.getElementById('app-container');
        const loginForm = document.getElementById('login-form');
        const walletAddressInput = document.getElementById('wallet-address');
        const loginError = document.getElementById('login-error');
        const mainContent = document.getElementById('main-content');
        const userProfileArea = document.getElementById('user-profile-area');
        const loader = document.getElementById('loader');
        const recommendedChannelsContainer = document.getElementById('recommended-channels');
        const sidebar = document.getElementById('sidebar');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const mobileMenuBtn = document.getElementById('mobile-menu-btn');
        const mobileMenuIcon = document.getElementById('mobile-menu-icon');
        const backButton = document.getElementById('back-button');
        const desktopToggleBtn = document.getElementById('desktop-toggle-sidebar');
        
        const modModal = document.getElementById('mod-modal');
        const modModalContent = document.getElementById('mod-modal-content');
        const modModalUsername = document.getElementById('mod-modal-username');
        const modModalCancel = document.getElementById('mod-modal-cancel');


        function requireAuth() {
            if (!currentUser) {
                loginModal.style.display = 'flex';
                setTimeout(() => document.querySelector('#login-modal > div').classList.remove('scale-95'), 10);
                return false;
            }
            return true;
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                const storedWallet = localStorage.getItem('walletAddress');
                if (storedWallet) {
                    await setupUser(storedWallet);
                } else {
                    currentUser = null;
                    updateUIForAuthState();
                    loader.classList.add('hidden');
                }
            } else {
                currentUser = null;
                currentLang = localStorage.getItem('lang') || 'en';
                setLanguage(currentLang);
                updateUIForAuthState();
                renderExplorePage();
                appContainer.classList.remove('opacity-0');
                loader.classList.add('hidden');
            }
        });

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            loginError.textContent = '';
            const walletAddress = walletAddressInput.value.trim();
            if (walletAddress.length < 32 || walletAddress.length > 44) {
                loginError.textContent = 'Please enter a valid Solana wallet address.';
                return;
            }
            loader.classList.remove('hidden');
            try {
                localStorage.setItem('walletAddress', walletAddress);
                if (!auth.currentUser) {
                    await signInAnonymously(auth);
                } else {
                    await setupUser(walletAddress);
                }
            } catch (error) {
                console.error("Login error:", error);
                loginError.textContent = 'There was an error logging in. Please try again.';
                localStorage.removeItem('walletAddress');
                loader.classList.add('hidden');
            }
        });
        
        async function setupUser(wallet) {
            const userRef = doc(db, "users", wallet);
            const userSnap = await getDoc(userRef);
            if (!userSnap.exists()) {
                await setDoc(userRef, {
                    walletAddress: wallet, username: `Wallet...${wallet.substring(wallet.length - 4)}`, profilePicture: `https://placehold.co/128x128/1a1a1a/4ade80?text=${wallet.substring(0,1)}`, bitBalance: 1000, creatorRewardsBalance: 0, createdAt: serverTimestamp(), authUid: auth.currentUser.uid, followersCount: 0, followingCount: 0
                });
            } else {
                if (!userSnap.data().username) await updateDoc(userRef, { username: `Wallet...${wallet.substring(wallet.length - 4)}` });
                if (userSnap.data().authUid !== auth.currentUser.uid) await updateDoc(userRef, { authUid: auth.currentUser.uid });
            }
            loadUserProfile(wallet);
        }

        async function loadUserProfile(wallet) {
            if (unsubscribeUser) unsubscribeUser();
            const userRef = doc(db, "users", wallet);
            let isInitialLoad = true;
            unsubscribeUser = onSnapshot(userRef, (docSnap) => {
                if (docSnap.exists()) {
                    currentUser = { ...docSnap.data(), walletAddress: docSnap.id };
                    if (isInitialLoad) {
                        currentLang = localStorage.getItem('lang') || 'en';
                        setLanguage(currentLang);
                        updateUIForAuthState();
                        loginModal.style.display = 'none';
                        appContainer.classList.remove('opacity-0');
                        loader.classList.add('hidden');
                        isInitialLoad = false;
                        currentPageRender();
                    }
                    renderHeader();
                } else { logout(); }
            }, (error) => { console.error("Error listening to user changes:", error); logout(); });
        }

        function updateUIForAuthState() {
            renderHeader();
            const creatorSection = document.getElementById('creator-section');
            if (creatorSection) creatorSection.style.display = currentUser ? 'block' : 'none';
            if (currentUser) {
                loadRecommendedChannels();
            } else {
                recommendedChannelsContainer.innerHTML = '';
            }
            if (!navigationHistory.length) { 
                 setupNavigation();
                 setupModModalListeners();
            }
        }
        
        function logout() {
            stopStream();
            if(unsubscribeUser) unsubscribeUser();
            localStorage.removeItem('walletAddress');
            if(auth.currentUser) auth.signOut();
            else {
                currentUser = null;
                updateUIForAuthState();
                renderExplorePage();
            }
        }

        function renderHeader() {
            if (currentUser) {
                userProfileArea.innerHTML = `
                    <div class="flex items-center gap-1 md:gap-2 bg-[var(--background-tertiary)] px-2 md:px-3 py-1.5 rounded-full">
                        <img src="${BIT_COIN_LOGO_URL}" class="w-5 h-5 rounded-full object-cover">
                        <span class="font-semibold text-white text-sm md:text-base">${currentUser.bitBalance.toLocaleString()} <span class="hidden sm:inline">BIT</span></span>
                    </div>
                    <button id="profile-button" class="group flex items-center gap-2">
                        <img src="${currentUser.profilePicture}" alt="Profile Picture" class="w-9 h-9 md:w-10 md:h-10 rounded-full object-cover border-2 border-[var(--border-color)] group-hover:border-[var(--brand-color-purple)] transition-colors">
                        <span class="hidden md:block font-semibold group-hover:text-[var(--brand-color-purple)]">${currentUser.username}</span>
                    </button>`;
            } else {
                userProfileArea.innerHTML = `
                    <button id="login-button-header" class="purple-gradient-bg text-white font-bold py-2 px-4 rounded-lg transition-all duration-300 transform hover:scale-105">
                        Log In
                    </button>`;
                document.getElementById('login-button-header').addEventListener('click', () => {
                     loginModal.style.display = 'flex';
                });
            }
            lucide.createIcons();
        }
        
        async function loadRecommendedChannels() {
            if(!currentUser) return;
            const usersQuery = query(collection(db, "users"), where("walletAddress", "!=", currentUser.walletAddress), limit(5));
            const usersSnapshot = await getDocs(usersQuery);
            recommendedChannelsContainer.innerHTML = '';
            usersSnapshot.forEach(doc => {
                const user = doc.data();
                const channelEl = document.createElement('div');
                channelEl.className = 'flex items-center gap-3 p-1 rounded-lg hover:bg-[var(--background-tertiary)] cursor-pointer';
                channelEl.innerHTML = `
                    <img src="${user.profilePicture}" class="w-8 h-8 rounded-full">
                    <div class="flex-1 overflow-hidden">
                        <p class="text-sm font-semibold truncate sidebar-text">${user.username || user.walletAddress.substring(0,6)}</p>
                        <p class="text-xs text-[var(--text-secondary)] sidebar-text">${user.followersCount || 0} ${translations[currentLang].followers}</p>
                    </div>`;
                recommendedChannelsContainer.appendChild(channelEl);
            });
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            document.getElementById('toast-message').textContent = message;
            toast.classList.toggle('bg-red-600', isError);
            toast.classList.toggle('bg-green-600', !isError);
            toast.classList.remove('translate-y-20', 'opacity-0');
            setTimeout(() => {
                toast.classList.add('translate-y-20', 'opacity-0');
            }, 4000);
        }

        function setupNavigation() {
            const pages = {
                'explore': { render: renderExplorePage, pageKey: 'explore', auth: false },
                'categories': { render: renderCategoriesPage, pageKey: 'categories', auth: false },
                'studio': { render: renderStudioPage, pageKey: 'studio', auth: true }
            };

            document.body.addEventListener('click', (e) => {
                const profileButton = e.target.closest('#profile-button');
                if (profileButton) {
                    if (!requireAuth()) return;
                    e.preventDefault();
                    navigationHistory.push(currentPageRender);
                    cleanupWatchPage();
                    renderSettingsPage();
                }

                const navAction = e.target.closest('.nav-action');
                if (navAction) {
                    e.preventDefault();
                    const targetPageKey = navAction.dataset.target;
                    const page = pages[targetPageKey];
                    if (page) {
                        if(page.auth && !requireAuth()) return;
                        navigationHistory.push(currentPageRender);
                        cleanupWatchPage();
                        currentPageRender = page.render;
                        currentPageRender();
                    }
                }
            });
            
            backButton.addEventListener('click', () => {
                if (navigationHistory.length > 0) {
                    cleanupWatchPage();
                    const previousPage = navigationHistory.pop();
                    if (typeof previousPage === 'function') {
                        currentPageRender = previousPage;
                        previousPage();
                    }
                }
            });

            function toggleSidebar() {
                sidebar.classList.toggle('-translate-x-full');
                sidebarBackdrop.classList.toggle('hidden');
                mobileMenuIcon.setAttribute('data-lucide', sidebar.classList.contains('-translate-x-full') ? 'menu' : 'x');
                lucide.createIcons();
            }

            mobileMenuBtn.addEventListener('click', toggleSidebar);
            sidebarBackdrop.addEventListener('click', toggleSidebar);
            sidebar.addEventListener('click', (e) => {
                if (e.target.closest('a.nav-action')) {
                    toggleSidebar();
                }
            });
            
            desktopToggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('md:w-64');
                sidebar.classList.toggle('md:w-20');
                
                const icon = document.getElementById('desktop-toggle-icon');
                const isCollapsed = sidebar.classList.contains('md:w-20');
                
                icon.setAttribute('data-lucide', isCollapsed ? 'sidebar-close' : 'sidebar-open');
                lucide.createIcons();
                
                document.querySelectorAll('.sidebar-text').forEach(el => {
                    el.classList.toggle('md:hidden', isCollapsed);
                });
                document.querySelectorAll('.nav-link[data-target] span').forEach(el => {
                     el.classList.toggle('md:hidden', isCollapsed);
                });
            });
        }
        
        function updateHeaderButtons(isSubPage) {
            backButton.classList.toggle('hidden', !isSubPage);
            mobileMenuBtn.classList.toggle('hidden', isSubPage);
        }

        function setActiveLink(activeTarget) {
             document.querySelectorAll('.nav-action[data-target]').forEach(link => {
                link.classList.toggle('active', link.dataset.target === activeTarget);
            });
        }

        function renderPage(content, activeTargetKey, isSubPage = false) {
            mainContent.innerHTML = `<div class="animate-slide-in">${content}</div>`;
            setActiveLink(activeTargetKey);
            updateHeaderButtons(isSubPage);
            setLanguage(currentLang);
            lucide.createIcons();
            if (carouselInterval) clearInterval(carouselInterval);
            carouselInterval = null;
        }
        
        // Renderizar un stream card para el carrusel grande
        function renderFeaturedStreamCard(streamDoc, streamIndex) {
            const stream = streamDoc.data();
            return `
                <div class="cover-carousel-item" data-index="${streamIndex}">
                    <div class="cover-carousel-item-inner stream-card" data-streamer-wallet="${streamDoc.id}">
                        <div class="relative">
                            <img src="${stream.thumbnailUrl || 'https://placehold.co/800x450/141418/2a2a32?text=En+Vivo'}" class="w-full aspect-video object-cover">
                            <div class="absolute top-2 left-2 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-md">LIVE</div>
                            <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded-md flex items-center gap-1"><i data-lucide="users" class="w-3 h-3"></i> ${stream.viewerCount || 0}</div>
                        </div>
                        <div class="p-4 flex items-start gap-3">
                            <img src="${stream.streamerPic}" class="w-10 h-10 rounded-full">
                            <div>
                                <h3 class="font-bold text-md truncate">${stream.title}</h3>
                                <p class="text-sm text-[var(--text-secondary)]">${stream.streamerUsername || stream.streamerWallet.substring(0, 6)}</p>
                                <span class="text-xs bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded-full mt-1 inline-block">${stream.category}</span>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        
        // Renderizar un stream card para la cuadrícula pequeña
        function renderStreamCard(streamDoc) {
            const stream = streamDoc.data();
            return `
                <div class="stream-card-small group bg-[var(--background-secondary)] rounded-xl overflow-hidden border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] transition-all transform hover:-translate-y-1 duration-300 cursor-pointer stream-card" data-streamer-wallet="${streamDoc.id}">
                    <div class="relative">
                        <img src="${stream.thumbnailUrl || 'https://placehold.co/400x225/141418/2a2a32?text=En+Vivo'}" class="thumbnail">
                        <div class="absolute top-2 left-2 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-md">LIVE</div>
                        <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded-md flex items-center gap-1"><i data-lucide="users" class="w-3 h-3"></i> ${stream.viewerCount || 0}</div>
                    </div>
                    <div class="card-content flex items-start gap-2">
                        <img src="${stream.streamerPic}" class="streamer-pic rounded-full">
                        <div>
                            <h3 class="card-title font-bold truncate">${stream.title}</h3>
                            <p class="card-info text-[var(--text-secondary)]">${stream.streamerUsername || stream.streamerWallet.substring(0, 6)}</p>
                            <span class="card-category bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded-full mt-1 inline-block">${stream.category}</span>
                        </div>
                    </div>
                </div>`;
        }
        
        async function renderExplorePage(category = null) {
            currentPageRender = () => renderExplorePage(category);
            let streamsQuery = query(collection(db, "streams"), where("status", "==", "live"));
            if (category) {
                streamsQuery = query(collection(db, "streams"), where("status", "==", "live"), where("category", "==", category));
            }
            
            const querySnapshot = await getDocs(streamsQuery);
            let featuredStreamsHTML = '';
            let remainingStreamsHTML = '';
            
            if (querySnapshot.empty) {
                remainingStreamsHTML = `<p class="text-center text-[var(--text-secondary)] col-span-full">${translations[currentLang].no_one_live.replace('%s', category || 'any')}</p>`;
            } else {
                let streamDocs = querySnapshot.docs;
                
                // Ordenar por viewerCount (más vistas)
                streamDocs.sort((a, b) => (b.data().viewerCount || 0) - (a.data().viewerCount || 0));
                
                // Tomar los 5 primeros (o menos) para el carrusel
                const featuredStreamDocs = streamDocs.slice(0, 5);
                const remainingStreamDocs = streamDocs.slice(5);

                if (featuredStreamDocs.length > 0) {
                    featuredStreamsHTML = featuredStreamDocs.map((doc, index) => renderFeaturedStreamCard(doc, index)).join('');
                }
                
                if (remainingStreamDocs.length > 0) {
                    remainingStreamsHTML = remainingStreamDocs.map(doc => renderStreamCard(doc)).join('');
                } else if (featuredStreamDocs.length === 0) {
                     remainingStreamsHTML = `<p class="text-center text-[var(--text-secondary)] col-span-full">${translations[currentLang].no_one_live.replace('%s', category || 'any')}</p>`;
                }
            }
            
            const title = category ? `Canales en Vivo - ${category}` : translations[currentLang].explore_title;
            
            const carouselHTML = featuredStreamsHTML ? `
                <div class="cover-carousel-container">
                    <div class="cover-carousel" id="featured-streams-carousel">
                        ${featuredStreamsHTML}
                    </div>
                    <div class="carousel-fade carousel-fade-left"></div>
                    <div class="carousel-fade carousel-fade-right"></div>
                    <button class="carousel-nav-btn prev" id="carousel-prev"><i data-lucide="chevron-left"></i></button>
                    <button class="carousel-nav-btn next" id="carousel-next"><i data-lucide="chevron-right"></i></button>
                </div>` : '';
            
            renderPage(`
                ${carouselHTML}
                <h1 class="text-3xl font-bold mb-6" data-key="explore_title">${title}</h1>
                <div class="streams-grid">
                    ${remainingStreamsHTML}
                </div>`, 'explore');
            
            if (featuredStreamsHTML) {
                setupCarousel();
            }

            document.querySelectorAll('.stream-card').forEach(card => {
                card.addEventListener('click', () => {
                    navigationHistory.push(currentPageRender);
                    const streamerWallet = card.dataset.streamerWallet;
                    renderWatchStreamPage(streamerWallet);
                });
            });
        }
        
        function setupCarousel() {
            const carousel = document.getElementById('featured-streams-carousel');
            if (!carousel) return;
            const items = carousel.querySelectorAll('.cover-carousel-item');
            if (items.length === 0) return;

            const prevBtn = document.getElementById('carousel-prev');
            const nextBtn = document.getElementById('carousel-next');

            const snapLogic = () => {
                const scrollLeft = carousel.scrollLeft;
                const carouselWidth = carousel.clientWidth;
                
                items.forEach(item => {
                    const itemLeft = item.offsetLeft - carousel.offsetLeft;
                    const itemWidth = item.clientWidth;
                    const itemCenter = itemLeft + itemWidth / 2;
                    const screenCenter = scrollLeft + carouselWidth / 2;
                    
                    if (Math.abs(itemCenter - screenCenter) < itemWidth / 2) {
                        item.classList.add('is-snapped');
                    } else {
                        item.classList.remove('is-snapped');
                    }
                });
            };
            
            carousel.addEventListener('scroll', snapLogic);
            snapLogic(); // Run on init
            
            const scrollBy = (direction) => {
                const currentItem = carousel.querySelector('.is-snapped') || items[0];
                let targetIndex = parseInt(currentItem.dataset.index);
                
                if (direction === 'next') {
                    targetIndex = (targetIndex + 1) % items.length;
                } else {
                    targetIndex = (targetIndex - 1 + items.length) % items.length;
                }
                
                items[targetIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            };

            prevBtn.addEventListener('click', () => scrollBy('prev'));
            nextBtn.addEventListener('click', () => scrollBy('next'));
            
            if (carouselInterval) clearInterval(carouselInterval);
            carouselInterval = setInterval(() => scrollBy('next'), 5000);
        }

        
        function renderCategoriesPage() {
            currentPageRender = renderCategoriesPage;
            const categoriesHTML = CATEGORIES.map(cat => `
                <div class="category-card group bg-[var(--background-secondary)] rounded-xl overflow-hidden border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] transition-all transform hover:-translate-y-1 duration-300 cursor-pointer" data-category="${cat}">
                    <img src="${CATEGORY_IMAGES[cat] || `https://placehold.co/300x400/141418/2a2a32?text=${cat.replace(' ', '+')}`}" class="w-full h-auto object-cover aspect-[3/4]">
                    <div class="p-4 bg-[var(--background-secondary)]"><h3 class="font-bold text-lg truncate">${cat}</h3></div>
                </div>`).join('');
            
            renderPage(`<h1 class="text-3xl font-bold mb-6" data-key="categories_title">Explore Categories</h1>
                <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6">${categoriesHTML}</div>`, 'categories');

            document.querySelectorAll('.category-card').forEach(card => {
                card.addEventListener('click', () => {
                    const category = card.dataset.category;
                    mainContent.innerHTML = `<div class="text-center p-8">${translations[currentLang].loading}...</div>`; 
                    renderExplorePage(category);
                });
            });
        }
        
        function renderSettingsPage() {
             currentPageRender = renderSettingsPage;
             const profileHTML = `
             <div class="space-y-4">
                <div><img src="https://placehold.co/1200x300/1f1f1f/1f1f1f" class="w-full h-40 object-cover rounded-2xl"></div>
                <div class="flex flex-col items-center -mt-20"><img src="${currentUser.profilePicture}" class="w-32 h-32 rounded-full object-cover border-4 border-[var(--background-primary)]">
                    <div class="text-center mt-2"><h1 class="text-2xl font-bold">${currentUser.username}</h1><p class="text-sm text-[var(--text-secondary)] break-all px-2">${currentUser.walletAddress}</p></div>
                </div>
                <div class="pt-4 grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="lg:col-span-1 space-y-6">
                        <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]"><h3 class="font-semibold text-lg mb-4" data-key="settings">Settings</h3>
                            <label for="lang-select" class="font-semibold text-sm" data-key="language">Language</label>
                            <select id="lang-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2">
                                <option value="en" ${currentLang === 'en' ? 'selected' : ''}>English</option><option value="es" ${currentLang === 'es' ? 'selected' : ''}>Español</option>
                            </select>
                        </div>
                        <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]"><h3 class="font-semibold text-lg mb-4" data-key="edit_profile">Edit Profile</h3>
                            <div class="space-y-3">
                                <div><label for="username-input" class="text-sm font-medium text-[var(--text-secondary)]" data-key="username">Username</label><input type="text" id="username-input" value="${currentUser.username}" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-purple)]"></div>
                                <div><label for="profile-pic-url" class="text-sm font-medium text-[var(--text-secondary)]" data-key="profile_pic_url">Profile Picture URL</label><input type="text" id="profile-pic-url" value="${currentUser.profilePicture}" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-purple)]"></div>
                            </div>
                            <button id="save-profile" class="mt-4 w-full purple-gradient-bg text-white font-semibold py-2 rounded-lg transition-all hover:scale-105" data-key="save">Save Changes</button>
                            <button id="logout-button" class="mt-3 w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded-lg transition-all" data-key="logout">Log Out</button>
                        </div>
                    </div>
                    <div class="lg:col-span-2 space-y-6">
                        <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]">
                            <h3 class="font-semibold text-lg mb-4 text-purple-400">Depositar BITS</h3>
                            <div class="bg-[var(--background-tertiary)] p-6 rounded-lg text-center">
                                <p class="text-sm text-[var(--text-secondary)] mb-3">Deposita tokens BITS usando Solana Pay o tu wallet Phantom.</p>
                                <div class="flex items-center justify-center mb-4 min-h-[144px]">
                                    <img id="solana-qr-img" src="" alt="QR de pago Solana" class="w-36 h-36 rounded-lg border border-[var(--border-color)] hidden opacity-0 transition-opacity duration-300">
                                </div>
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-3">
                                    <input id="bits-amount" type="number" min="1" step="1" placeholder="Monto en BITS" class="bg-[var(--background-secondary)] p-2 rounded-lg text-center w-full">
                                    <button id="bits-gen-btn" class="purple-gradient-bg text-white font-semibold py-2 rounded-lg">Generar QR</button>
                                </div>
                                <button id="phantom-pay-btn" class="w-full bg-purple-700 hover:bg-purple-800 text-white font-bold py-2 px-4 rounded-lg transition-all flex items-center justify-center gap-2">
                                    <img src="https://cimg.co/wp-content/uploads/2025/08/19125824/1755608303-phantom-wallet-logo.png" class="w-5 h-5"/> Pagar con Phantom
                                </button>
                                <p id="bits-status" class="text-sm text-gray-400 mt-3 h-5">Estado: esperando...</p>
                            </div>
                        </div>
                        <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]">
                            <h3 class="font-semibold text-lg mb-4" data-key="balance_withdrawal">Balance & Withdrawal</h3>
                            <div class="bg-[var(--background-tertiary)] p-6 rounded-lg mb-6">
                                <p class="text-sm text-[var(--text-secondary)]" data-key="current_balance">Your Current Balance</p>
                                <div class="flex items-center gap-2"><img src="${BIT_COIN_LOGO_URL}" class="w-10 h-10 rounded-full object-cover"><p class="text-4xl font-bold text-white">${currentUser.bitBalance.toLocaleString()} <span class="text-2xl font-normal text-purple-300">BIT</span></p></div>
                                <p class="text-lg text-green-400 h-7 mt-2" id="usd-equivalent-display">...</p>
                            </div>
                            <p class="text-sm text-[var(--text-secondary)]" id="withdrawal-info-text" data-key="withdrawal_minimum_bit">You need a minimum of ${WITHDRAWAL_MINIMUM_BIT.toLocaleString()} BIT to withdraw.</p>
                            <div id="token-price-info" class="text-xs text-gray-500 h-4 mt-1"></div>
                            <button id="withdraw-button" class="mt-4 w-full purple-gradient-bg text-white font-bold py-3 rounded-lg transition-all disabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled data-key="request_withdrawal">Request Withdrawal</button>
                            <div id="withdraw-message" class="text-center text-sm h-5 mt-2"></div>
                        </div>
                        
                        <!-- Historial de Transacciones -->
                        <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]">
                            <h3 class="font-semibold text-lg mb-4" data-key="transaction_history">Historial de Transacciones</h3>
                            <div id="transaction-history-container" class="space-y-3 max-h-96 overflow-y-auto pr-2">
                                <!-- El historial se cargará aquí dinámicamente -->
                                <p id="transaction-history-loading" class="text-[var(--text-secondary)] text-sm">Cargando historial...</p>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>`;
            renderPage(profileHTML, null, true); 
            document.getElementById('save-profile').addEventListener('click', saveProfile); 
            document.getElementById('logout-button').addEventListener('click', logout); 
            document.getElementById('withdraw-button').addEventListener('click', requestWithdrawal); 
            document.getElementById('lang-select').addEventListener('change', (e) => setLanguage(e.target.value));
            
            initBitsDepositLogic();
            updateWithdrawalStatus(); 
            loadTransactionHistory();
        }
        
        async function logTransaction(type, amount, details = {}) {
            if (!currentUser) return;
            try {
                const txCollection = collection(db, "users", currentUser.walletAddress, "transactions");
                await addDoc(txCollection, {
                    type, // 'deposit', 'withdrawal', 'subscription_purchase', 'subscription_reward', 'vip_emoji_purchase', 'vip_emoji_reward', 'reward_transfer'
                    amount, // puede ser positivo o negativo
                    timestamp: serverTimestamp(),
                    ...details // E.g., { toUser: '...', fromUser: '...', emojiId: '...' }
                });
            } catch (error) {
                console.error("Error logging transaction:", error);
            }
        }
        
        async function loadTransactionHistory() {
            if (!currentUser) return;
            const container = document.getElementById('transaction-history-container');
            const loadingText = document.getElementById('transaction-history-loading');
            
            const txQuery = query(collection(db, "users", currentUser.walletAddress, "transactions"), orderBy("timestamp", "desc"), limit(20));
            
            onSnapshot(txQuery, (snapshot) => {
                if (snapshot.empty) {
                    loadingText.textContent = translations[currentLang].no_transactions;
                    return;
                }
                
                container.innerHTML = ''; // Limpiar
                
                snapshot.forEach(doc => {
                    const tx = doc.data();
                    const el = document.createElement('div');
                    el.className = 'bg-[var(--background-tertiary)] p-3 rounded-lg flex justify-between items-center';
                    
                    const date = tx.timestamp ? tx.timestamp.toDate().toLocaleString(currentLang.startsWith('es') ? 'es-ES' : 'en-US') : '...';
                    let amountColor = tx.amount > 0 ? 'text-green-400' : 'text-red-400';
                    if (tx.type === 'reward_transfer' || tx.type === 'stream_reward' || tx.type === 'subscription_reward' || tx.type === 'vip_emoji_reward') amountColor = 'text-purple-400';
                    
                    let description = translations[currentLang][`tx_${tx.type}`] || tx.type;
                    if (tx.details?.username) {
                        description += ` (${tx.details.username})`;
                    } else if (tx.type === 'deposit') {
                        description += ` (${tx.details?.method || 'QR'})`;
                    }
                    
                    el.innerHTML = `
                        <div>
                            <p class="font-semibold text-sm">${description}</p>
                            <p class="text-xs text-[var(--text-secondary)]">${date}</p>
                        </div>
                        <span class="font-bold ${amountColor}">${tx.amount.toLocaleString()} BIT</span>
                    `;
                    container.appendChild(el);
                });
                
            }, (error) => {
                console.error("Error loading transaction history:", error);
                loadingText.textContent = "Error al cargar el historial.";
            });
        }

 
function initBitsDepositLogic() {
    const btnQR = document.getElementById("bits-gen-btn");
    const btnPhantom = document.getElementById("phantom-pay-btn");
    const input = document.getElementById("bits-amount");
    const img = document.getElementById("solana-qr-img");
    const status = document.getElementById("bits-status");
    const loader = document.getElementById('loader');

    if (!btnQR || !btnPhantom || !input || !img || !status) return;

    const RECIPIENT_WALLET = "6MX2SNsqyFbbwBQhuYngVXUXs4MseEpz3abiyN9pDZfA";
    const TOKEN_MINT_ADDRESS = "EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump";
    const SOLANA_RPC_URL = "https://solana-mainnet.gateway.tatum.io/";
    const TATUM_API_KEY = "t-68f69f0447bf5156a36067b3-b0b00e1660324a54ad70ef28";
    const TOKEN_DECIMALS = 6;
    
    // Limpiar intervalos anteriores
    if (window.depositPollingInterval) {
        clearInterval(window.depositPollingInterval);
    }
    
    // Almacenamiento local de firmas procesadas para evitar duplicados
    let processingSignatures = new Set();

    async function startQrPolling(reference, amount, solanaPayUrl) {
        if (window.depositPollingInterval) clearInterval(window.depositPollingInterval);
        
        status.innerHTML = `Escanea el QR para pagar ${amount} BITS. Esperando pago... <div class="w-4 h-4 border-2 border-dashed rounded-full animate-spin inline-block ml-2"></div>`;
        
        let pollCount = 0;
        const maxPolls = 90; // 7.5 minutos

        window.depositPollingInterval = setInterval(async () => {
            pollCount++;
            console.log(`[Tatum API] Buscando pago con referencia: ${reference} (Intento ${pollCount}/${maxPolls})`);

            if (pollCount > maxPolls) {
                clearInterval(window.depositPollingInterval);
                status.textContent = "Tiempo de espera agotado. La transacción puede estar pendiente. Verifica tu wallet.";
                return;
            }
            
            try {
                const response = await fetch(SOLANA_RPC_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': TATUM_API_KEY
                    },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getSignaturesForAddress',
                        params: [RECIPIENT_WALLET, { limit: 50 }]
                    })
                });

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                const signatures = data.result;
                const foundSignature = signatures.find(sigInfo => 
                    sigInfo.memo && sigInfo.memo.includes(reference)
                );

                if (foundSignature) {
                    console.log("✅ Pago detectado con firma:", foundSignature.signature);
                    
                    if (processingSignatures.has(foundSignature.signature)) {
                        console.log("⚠️ Transacción ya en proceso de verificación.");
                        return;
                    }
                    processingSignatures.add(foundSignature.signature);
                    
                    // Verificar si ya procesamos esta transacción en Firebase
                    const signatureRef = doc(db, "users", currentUser.walletAddress, "usedSignatures", foundSignature.signature);
                    const signatureDoc = await getDoc(signatureRef);
                    
                    if (signatureDoc.exists()) {
                        console.log("⚠️ Transacción ya procesada anteriormente en Firebase");
                        status.textContent = "⚠️ Esta transacción ya fue procesada.";
                        clearInterval(window.depositPollingInterval);
                        processingSignatures.delete(foundSignature.signature);
                        return;
                    }

                    clearInterval(window.depositPollingInterval);
                    
                    status.textContent = `✅ ¡Pago detectado! Verificando transacción...`;
                    
                    const connection = new solanaWeb3.Connection(SOLANA_RPC_URL, {
                        commitment: 'confirmed',
                        httpHeaders: { 'x-api-key': TATUM_API_KEY },
                        confirmTransactionInitialTimeout: 60000 // 60 segundos timeout
                    });

                    try {
                        status.textContent = `✅ Confirmando transacción (Esperando blockchains)...`;
                        
                        const confirmation = await connection.confirmTransaction(
                            foundSignature.signature, 
                            'confirmed'
                        );
                        
                        console.log("✅ Transacción confirmada:", confirmation);

                        const txDetails = await connection.getParsedTransaction(foundSignature.signature, 'confirmed');
                        if (!txDetails || !txDetails.meta) {
                            throw new Error("No se pudieron obtener los detalles de la transacción.");
                        }
                        
                        if (txDetails.meta.err) {
                            throw new Error("La transacción fallió: " + JSON.stringify(txDetails.meta.err));
                        }

                        const postBalances = txDetails.meta.postTokenBalances?.find(tb => 
                            tb.mint === TOKEN_MINT_ADDRESS && tb.owner === RECIPIENT_WALLET
                        );
                        const preBalances = txDetails.meta.preTokenBalances?.find(tb => 
                            tb.mint === TOKEN_MINT_ADDRESS && tb.owner === RECIPIENT_WALLET
                        );
                        
                        const prevAmount = preBalances ? parseFloat(preBalances.uiTokenAmount.uiAmount) : 0;
                        const postAmount = postBalances ? parseFloat(postBalances.uiTokenAmount.uiAmount) : 0;
                        const transferredAmount = postAmount - prevAmount;

                        console.log("📊 Análisis de transacción:", { prevAmount, postAmount, transferredAmount, expectedAmount: amount });

                        if (transferredAmount >= amount) {
                            await processSuccessfulPayment(signatureRef, foundSignature.signature, amount, transferredAmount, reference, 'qr');
                        } else {
                            status.textContent = `⚠️ Pago detectado pero el monto es incorrecto. Se transfirieron ${transferredAmount} BITS, se esperaban ${amount} BITS.`;
                            console.warn("Monto de la transacción no coincide.", { expected: amount, actual: transferredAmount });
                            processingSignatures.delete(foundSignature.signature); // Permitir re-intento si falla
                        }

                    } catch (confirmationError) {
                        console.warn("Error en confirmación, verificando estado de la transacción:", confirmationError);
                        if (confirmationError.message.includes('timeout') || confirmationError.message.includes('not confirmed')) {
                            await handleUnconfirmedTransaction(connection, foundSignature.signature, signatureRef, amount, reference, 'qr');
                        } else {
                            throw confirmationError;
                        }
                    }

                }
            } catch (err) {
                console.error("Error durante el sondeo de QR:", err);
                status.textContent = `❌ Error: ${err.message}`;
                // No limpiar processingSignatures aquí, podría ser un error temporal
            }
        }, 5000); // Verificar cada 5 segundos
    }

    async function handleUnconfirmedTransaction(connection, signature, signatureRef, amount, reference, method) {
        status.textContent = "⏳ La transacción está tomando más tiempo de lo esperado. Verificando estado...";
        
        try {
            const txDetails = await connection.getTransaction(signature, { commitment: 'confirmed' });
            
            if (!txDetails) {
                const txDetailsFinalized = await connection.getTransaction(signature, { commitment: 'finalized' });
                if (txDetailsFinalized && !txDetailsFinalized.meta?.err) {
                    await processSuccessfulPayment(signatureRef, signature, amount, amount, reference, "finalized", method);
                    return;
                }
                status.innerHTML = `⏳ Transacción pendiente. <a href="https://solscan.io/tx/${signature}" target="_blank" class="text-purple-400 underline">Ver en explorador</a>. Se verificará automáticamente.`;
                continueBackgroundVerification(signature, amount, reference, method);
                return;
            }
            
            if (!txDetails.meta?.err) {
                await processSuccessfulPayment(signatureRef, signature, amount, amount, reference, "confirmed", method);
            } else {
                throw new Error("Transacción fallida: " + JSON.stringify(txDetails.meta.err));
            }
            
        } catch (verificationError) {
            console.error("Error en verificación de transacción:", verificationError);
            status.innerHTML = `⚠️ No se pudo verificar el estado. <a href="https://solscan.io/tx/${signature}" target="_blank" class="text-purple-400 underline">Verifica manually</a> y contacta soporte si es necesario.`;
            processingSignatures.delete(signature); // Permitir re-intento si falla
        }
    }

    async function continueBackgroundVerification(signature, amount, reference, method) {
        const backgroundInterval = setInterval(async () => {
            try {
                const connection = new solanaWeb3.Connection(SOLANA_RPC_URL, {
                    commitment: 'confirmed',
                    httpHeaders: { 'x-api-key': TATUM_API_KEY }
                });
                
                const txDetails = await connection.getTransaction(signature, { commitment: 'finalized' });
                
                if (txDetails && !txDetails.meta?.err) {
                    clearInterval(backgroundInterval);
                    const signatureRef = doc(db, "users", currentUser.walletAddress, "usedSignatures", signature);
                    await processSuccessfulPayment(signatureRef, signature, amount, amount, reference, "finalized (background)", method);
                    showToast(`¡Transacción confirmada! Se añadieron ${amount} BITS a tu cuenta.`);
                }
            } catch (error) {
                console.log("Verificación en segundo plano:", error.message);
            }
        }, 10000); // Verificar cada 10 segundos
    }

    async function processSuccessfulPayment(signatureRef, signature, expectedAmount, actualAmount, reference, confirmationType = "confirmed", method = 'unknown') {
        
        // --- ¡CORRECCIÓN CLAVE! ---
        // Verificar si esta firma ya se está procesando o se procesó.
        if (processingSignatures.has(signature) && status.textContent.includes('¡Transacción')) {
             console.log("⚠️ Bloqueo de duplicado: processSuccessfulPayment ya fue llamado para", signature);
             return;
        }
        processingSignatures.add(signature);
        
        status.textContent = `✅ ¡Transacción ${confirmationType}! Actualizando saldo...`;
        
        try {
            // DOBLE VERIFICACIÓN en Firebase antes de escribir
            const sigDoc = await getDoc(signatureRef);
            if (sigDoc.exists()) {
                console.log("⚠️ Bloqueo de duplicado: La firma ya existe en Firebase.", signature);
                status.textContent = "✅ Transacción ya acreditada.";
                processingSignatures.delete(signature);
                return;
            }

            // Marcar la transacción como procesada
            await setDoc(signatureRef, {
                processedAt: serverTimestamp(),
                amount: actualAmount,
                expectedAmount: expectedAmount,
                reference: reference,
                confirmationType: confirmationType,
                signature: signature
            });

            // Actualizar el balance del usuario usando increment
            const userRef = doc(db, "users", currentUser.walletAddress);
            await updateDoc(userRef, { 
                bitBalance: increment(expectedAmount) 
            });
            
            // Registrar transacción de depósito
            await logTransaction('deposit', expectedAmount, { method: method, signature: signature });

            showToast(`¡Se han añadido ${expectedAmount} BITS a tu cuenta!`);
            status.innerHTML = `✅ Depósito exitoso (${confirmationType}). <a href="https://solscan.io/tx/${signature}" target="_blank" class="text-purple-400 underline">Ver en explorador</a>`;
            document.getElementById("bits-amount").value = '';
            document.getElementById("solana-qr-img").classList.add("hidden", "opacity-0");
            
            const payButton = document.getElementById("solana-pay-button");
            if (payButton) payButton.classList.add("hidden");
            
            console.log("✅ Balance actualizado correctamente");
            
        } catch (firebaseError) {
            console.error("Error actualizando Firebase:", firebaseError);
            status.textContent = "❌ Error al actualizar el balance. Contacta con soporte.";
            showToast("Error al actualizar el balance. Contacta con soporte.", true);
            // Si falla firebase, borramos el "lock" local para permitir re-intento manual
            processingSignatures.delete(signature);
            // Nota: No borramos el doc en usedSignatures, por si el error fue en bitBalance
        }
        // No borramos la firma de processingSignatures.
        // Debe quedar ahí para evitar que CUALQUIER otra llamada (QR o Phantom) la procese.
    }

    function createSolanaPayButton(solanaPayUrl, amount, reference) {
        const existingButton = document.getElementById("solana-pay-button");
        if (existingButton) existingButton.remove();

        const payButton = document.createElement("button");
        payButton.id = "solana-pay-button";
        payButton.type = "button";
        payButton.className = "w-full bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg flex items-center justify-center gap-2 mb-4";
        payButton.innerHTML = `
            <i data-lucide="wallet" class="w-5 h-5"></i>
            <span>Pagar ${amount} BITS </span>
        `;

        payButton.addEventListener("click", function() {
            if (/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) {
                window.location.href = solanaPayUrl;
            } else {
                window.open(solanaPayUrl, '_blank');
            }
        });

        const gridContainer = document.querySelector('.grid.grid-cols-1.sm\\:grid-cols-2.gap-3.mb-3');
        if (gridContainer) {
            gridContainer.parentNode.insertBefore(payButton, gridContainer.nextSibling);
        } else {
            const qrButtonContainer = btnQR.parentElement;
            qrButtonContainer.parentNode.insertBefore(payButton, qrButtonContainer.nextSibling);
        }
        lucide.createIcons();
    }

    function makeQRClickeable(qrElement, solanaPayUrl) {
        qrElement.style.cursor = 'pointer';
        qrElement.title = 'Haz clic para abrir Solana Pay';
        
        qrElement.addEventListener('click', function() {
            if (/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) {
                window.location.href = solanaPayUrl;
            } else {
                window.open(solanaPayUrl, '_blank');
            }
        });
    }

    btnQR.addEventListener("click", () => {
        if (window.depositPollingInterval) clearInterval(window.depositPollingInterval);
        
        const amount = parseFloat(input.value);
        if (!amount || amount <= 0) {
            status.textContent = "❌ Ingresa un monto válido.";
            return;
        }
        
        if (!currentUser) {
            status.textContent = "❌ Debes iniciar sesión primero.";
            return;
        }
        
        const reference = `LP${Date.now()}${Math.random().toString(36).substring(2, 8)}`;
        const solanaPayUrl = `solana:${RECIPIENT_WALLET}?amount=${amount}&spl-token=${TOKEN_MINT_ADDRESS}&memo=${encodeURIComponent(reference)}&label=LivePayout&message=Depósito%20de%20${amount}%20BITS`;
        
        QRCode.toDataURL(solanaPayUrl, { width: 300, colorDark: "#14F195", colorLight: "#00000000" }, (err, dataUrl) => {
            if (!err) {
                img.src = dataUrl;
                img.classList.remove("hidden");
                requestAnimationFrame(() => img.classList.add("opacity-100"));
                makeQRClickeable(img, solanaPayUrl);
                createSolanaPayButton(solanaPayUrl, amount, reference);
                startQrPolling(reference, amount, solanaPayUrl);
            } else {
                status.textContent = "❌ Error al generar QR.";
            }
        });
    });

    btnPhantom.addEventListener("click", async () => {
        if (window.depositPollingInterval) clearInterval(window.depositPollingInterval);

        const amount = parseFloat(input.value);
        if (!amount || amount <= 0) {
            showToast("Por favor, ingresa un monto válido para depositar.", true);
            return;
        }

        if (!currentUser) {
            status.textContent = "❌ Debes iniciar sesión primero.";
            return;
        }

        const provider = window.solana;
        if (!provider || !provider.isPhantom) {
            status.innerHTML = `❌ No se detectó Phantom. <a href="https://phantom.app/" target="_blank" class="text-purple-400 underline">Instálala aquí</a>.`;
            showToast("Por favor, instala la extensión de Phantom para continuar.", true);
            return;
        }
        
        loader.classList.remove('hidden');
        status.textContent = "Conectando a Phantom...";

        try {
            await provider.connect({ onlyIfTrusted: false });
            
            const connection = new solanaWeb3.Connection(SOLANA_RPC_URL, {
                commitment: 'confirmed',
                httpHeaders: { 'x-api-key': TATUM_API_KEY },
                confirmTransactionInitialTimeout: 60000
            });
            const fromWallet = new solanaWeb3.PublicKey(currentUser.walletAddress);
            const toWallet = new solanaWeb3.PublicKey(RECIPIENT_WALLET);
            const mint = new solanaWeb3.PublicKey(TOKEN_MINT_ADDRESS);

            status.textContent = "Verificando cuenta de token...";
            const fromAta = await splToken.getAssociatedTokenAddress(mint, fromWallet);
            const fromAtaInfo = await connection.getAccountInfo(fromAta);
            if (!fromAtaInfo) {
                status.textContent = "❌ No tienes una cuenta para el token BIT.";
                showToast("No se encontró una cuenta para el token BIT en tu wallet. Asegúrate de tener BITS.", true);
                throw new Error("Token account not found.");
            }
            
            status.textContent = "Creando transacción...";
            const toAta = await splToken.getAssociatedTokenAddress(mint, toWallet);
            const reference = `LP${Date.now()}${Math.random().toString(36).substring(2, 8)}`;
            
            const transaction = new solanaWeb3.Transaction().add(
                splToken.createTransferInstruction(
                    fromAta,
                    toAta,
                    fromWallet,
                    amount * Math.pow(10, TOKEN_DECIMALS)
                ),
                new solanaWeb3.TransactionInstruction({
                    keys: [],
                    programId: new solanaWeb3.PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),
                    data: Buffer.from(reference, 'utf8')
                })
            );

            const { blockhash } = await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = fromWallet;
            
            status.textContent = "Por favor, aprueba la transacción en Phantom...";
            const { signature } = await provider.signAndSendTransaction(transaction);
            
            if (processingSignatures.has(signature)) {
                 console.log("⚠️ Transacción ya en proceso (Phantom).");
                 return;
            }
            processingSignatures.add(signature);
            
            status.textContent = "Procesando transacción en la red... (puede tomar hasta 60 segundos)";
            
            try {
                const confirmation = await connection.confirmTransaction(signature, 'confirmed');
                
                if (confirmation.value.err) {
                    throw new Error("La transacción falló en la red");
                }

                await processSuccessfulPayment(
                    doc(db, "users", currentUser.walletAddress, "usedSignatures", signature),
                    signature,
                    amount,
                    amount,
                    reference,
                    'phantom',
                    'phantom'
                );

            } catch (confirmationError) {
                console.warn("Error en confirmación Phantom:", confirmationError);
                await handleUnconfirmedTransaction(connection, signature, 
                    doc(db, "users", currentUser.walletAddress, "usedSignatures", signature),
                    amount, reference, 'phantom'
                );
            }

        } catch (error) {
            console.error("Phantom payment error:", error);
            if (error.message !== "Token account not found.") {
                 status.textContent = "❌ Transacción fallida o cancelada.";
                 showToast(error.message || "La transacción fue rechazada o falló.", true);
            }
        } finally {
            loader.classList.add('hidden');
        }
    });
}
        
        function renderStudioPage() {
            currentPageRender = renderStudioPage;
            const studioHTML = `
                <div class="bg-[var(--background-secondary)] rounded-2xl border border-[var(--border-color)] min-h-[70vh] flex flex-col md:flex-row">
                    <div class="w-full md:w-1/3 lg:w-1/4 border-b md:border-b-0 md:border-r border-[var(--border-color)] p-4 space-y-2">
                        <h2 class="text-xl font-bold p-2" data-key="creator_studio">Creator Studio</h2>
                        <button class="studio-tab-btn w-full text-left flex items-center gap-3 px-3 py-2.5 rounded-lg" data-target="studio-stream"><i data-lucide="video"></i><span data-key="stream">Stream</span></button>
                        <button class="studio-tab-btn w-full text-left flex items-center gap-3 px-3 py-2.5 rounded-lg" data-target="studio-analytics"><i data-lucide="bar-chart-2"></i><span data-key="analytics_rewards">Analytics & Rewards</span></button>
                    </div><div id="studio-content" class="w-full md:w-2/3 lg:w-3/4 p-4 md:p-8"></div>
                </div>`;
            renderPage(studioHTML, 'studio', true);
            const tabButtons = document.querySelectorAll('.studio-tab-btn');
            const studioContent = document.getElementById('studio-content');
            const tabs = { 'studio-stream': renderStudioStream, 'studio-analytics': renderStudioAnalytics };
            function switchTab(targetId) {
                tabButtons.forEach(btn => btn.classList.toggle('bg-[var(--background-tertiary)]', btn.dataset.target === targetId));
                studioContent.innerHTML = `<div class="animate-fade-in">${tabs[targetId]()}</div>`;
                setLanguage(currentLang);
                lucide.createIcons();
                if(targetId === 'studio-analytics') attachAnalyticsListeners();
                if(targetId === 'studio-stream') attachStreamListeners();
            }
            tabButtons.forEach(btn => btn.addEventListener('click', () => switchTab(btn.dataset.target)));
            switchTab('studio-stream');
        }
        
        let unsubscribeChat = null;
        let unsubscribeStream = null;
        let viewerPeerConnection = null;
        async function renderWatchStreamPage(streamerWallet) {
            currentPageRender = () => renderWatchStreamPage(streamerWallet);
            mainContent.classList.add('!p-0', 'md:!p-0', '!overflow-hidden');

            const streamerDoc = await getDoc(doc(db, "users", streamerWallet));
            const streamerData = streamerDoc.exists() ? streamerDoc.data() : { profilePicture: '', followersCount: 0, username: 'Streamer' };
            
            const watchHTML = `
            <div class="w-full h-full flex flex-col lg:flex-row">
                <!-- Top section (scrollable): Video + info -->
                <div class="flex-1 lg:p-8 p-4 overflow-y-auto">
                    <div class="flex flex-col gap-4 max-w-4xl mx-auto">
                         <div id="video-container" class="relative w-full aspect-video bg-black rounded-lg flex items-center justify-center flex-shrink-0">
                            <div id="video-overlay" class="absolute inset-0 flex items-center justify-center text-white text-xl z-10" data-key="connecting_stream">Connecting to stream...</div>
                            <video id="remote-video" autoplay playsinline class="w-full h-full object-contain opacity-0 transition-opacity duration-500"></video>
                        </div>
                        <div id="stream-info-panel">
                            <div class="bg-[var(--background-secondary)] p-4 rounded-lg border border-[var(--border-color)] flex flex-col sm:flex-row justify-between items-center gap-4">
                                <div class="flex items-center gap-4">
                                    <h2 id="stream-title-display" class="font-bold text-lg">Loading...</h2>
                                    <p class="text-sm text-[var(--text-secondary)]">${streamerData.username} | ${streamerData.followersCount || 0} <span data-key="followers">followers</span></p>
                                </div>
                            </div>
                            <div class="flex items-center gap-2 mt-2">
                                <button id="follow-btn" class="font-bold py-2 px-6 rounded-lg transition-all h-11 flex-1 bg-gray-800 text-center"></button>
                                <button id="subscribe-btn" class="purple-gradient-bg hover:opacity-90 text-white font-bold py-2 px-6 rounded-lg flex items-center justify-center gap-2 h-11 flex-1">
                                    <i data-lucide="star" class="w-4 h-4"></i> <span data-key="subscribe">Subscribe</span> (100 BIT)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Bottom section (fixed height on mobile): Chat -->
                <div class="w-full lg:w-80 lg:max-h-full flex-shrink-0 bg-[var(--background-secondary)] lg:rounded-lg p-4 flex flex-col border-t lg:border-l lg:border-t-0 border-[var(--border-color)] h-1/2 lg:h-auto">
                    <h3 class="font-bold text-lg mb-2 flex-shrink-0" data-key="live_chat">Live Chat</h3>
                    <div id="chat-messages" class="flex-grow space-y-2 overflow-y-auto pr-2 min-h-0"></div>
                    <div id="chat-input-container" class="flex-shrink-0 relative mt-auto pt-4" style="padding-bottom: env(safe-area-inset-bottom);">
                         <div id="vip-emoji-panel" class="hidden absolute bottom-full mb-2 left-0 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2 grid grid-cols-5 gap-2">
                           ${VIP_EMOJIS.map(e => `<button class="vip-emoji-btn group" data-emoji-id="${e.id}"><img src="${e.url}" class="w-10 h-10 transition-transform group-hover:scale-110"><div class="text-xs flex items-center justify-center gap-1">${e.price} <img src="${BIT_COIN_LOGO_URL}" class="w-3 h-3 rounded-full object-cover inline-block"></div></button>`).join('')}
                        </div>
                        <form id="chat-form" class="flex gap-2">
                           <button type="button" id="open-vip-emojis" class="flex-shrink-0 p-2 purple-gradient-bg hover:opacity-90 rounded-lg"><i data-lucide="smile"></i></button>
                           <input type="text" id="chat-input" data-key-placeholder="chat_placeholder" placeholder="Send a message..." class="flex-grow bg-[var(--background-tertiary)] rounded-lg px-3 py-2 text-sm min-w-0" required>
                           <button type="submit" class="flex-shrink-0 purple-gradient-bg px-3 rounded-lg"><i data-lucide="send"></i></button>
                        </form>
                    </div>
                </div>
            </div>`;
            mainContent.innerHTML = watchHTML;
            setLanguage(currentLang);
            lucide.createIcons();
            updateHeaderButtons(true);
            
            joinStream(streamerWallet);
            if (!currentUser) {
                document.getElementById('chat-input-container').innerHTML = `<div class="text-center p-4 py-6 text-sm text-gray-400 rounded-lg bg-[var(--background-tertiary)]">Please <button id="login-prompt-chat" class="text-purple-400 font-bold hover:underline">log in</button> to chat or interact.</div>`;
                document.getElementById('stream-info-panel').style.display = 'none';
                document.getElementById('login-prompt-chat').onclick = () => { loginModal.style.display = 'flex'; };
            } else {
                setupFollowButton(streamerWallet);
                setupSubscribeButton(streamerWallet);
                setupVipEmojiPanel(streamerWallet);
            }
            
            unsubscribeStream = onSnapshot(doc(db, "streams", streamerWallet), (docSnap) => {
                if (!docSnap.exists()) {
                    showToast(translations[currentLang].stream_ended);
                    if (currentPageRender === renderWatchStreamPage) { // Evitar doble render si ya estamos navegando
                         renderExplorePage();
                    }
                } else {
                    document.getElementById('stream-title-display').textContent = docSnap.data().title;
                }
            });
            
            const chatMessages = document.getElementById('chat-messages');
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const chatRef = collection(db, 'streams', streamerWallet, 'chat');
            const q = query(chatRef, orderBy("createdAt", "desc"), limit(50));
            
            unsubscribeChat = onSnapshot(q, async (snapshot) => {
                snapshot.docChanges().reverse().forEach(async change => {
                    if (change.type === "added") {
                        const msg = change.doc.data();
                        const msgEl = document.createElement('div');
                        if (msg.vipEmoji) {
                            msgEl.className = 'super-chat';
                            msgEl.innerHTML = `<div class="flex items-center gap-2 mb-2"><img src="${msg.vipEmoji.url}" class="w-10 h-10"><div class="font-bold text-lg">${msg.userName} ${translations[currentLang].sent} ${msg.vipEmoji.price} BIT</div></div><p class="text-white text-md">${msg.text}</p>`;
                        } else {
                            const isSub = currentUser && (await getDoc(doc(db, "users", streamerWallet, "subscribers", msg.userWallet))).exists();
                            msgEl.className = 'text-sm';
                            // Mensaje del sistema (MOD)
                            if (msg.userWallet === 'system') {
                                msgEl.innerHTML = `<p class="font-bold" style="color: ${msg.userColor || '#FF0000'}">${msg.text}</p>`;
                            } else {
                                msgEl.innerHTML = `<p>${isSub ? '<svg class="member-badge" viewBox="0 0 24 24" fill="gold"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></svg>' : ''}<strong class="font-semibold" style="color: ${msg.userColor || '#FFFFFF'}">${msg.userName}:</strong> ${msg.text}</p>`;
                            }
                        }
                        chatMessages.appendChild(msgEl);
                    }
                });
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });
            
            if(chatForm) chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!requireAuth()) return;
                
                try {
                    const banRef = doc(db, 'streams', streamerWallet, 'bans', currentUser.walletAddress);
                    const banSnap = await getDoc(banRef);
                    
                    if (banSnap.exists()) {
                        const banData = banSnap.data();
                        const expiresAt = banData.expiresAt ? banData.expiresAt.toDate() : null;
                        
                        if (expiresAt === null || expiresAt > new Date()) {
                            showToast(translations[currentLang].you_are_banned, true);
                            return;
                        } else {
                            await deleteDoc(banRef);
                        }
                    }
                } catch (err) {
                    console.error("Error checking ban status:", err);
                }
                
                const text = chatInput.value.trim();
                if (text) {
                    addDoc(chatRef, { text, userName: currentUser.username, userWallet: currentUser.walletAddress, userColor: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'), createdAt: serverTimestamp() });
                    chatInput.value = '';
                }
            });
        }
        
        function cleanupWatchPage() {
            mainContent.classList.remove('!p-0', 'md:!p-0', '!overflow-hidden');
            mainContent.classList.add('p-4', 'md:p-8');
            if (unsubscribeChat) unsubscribeChat();
            if (unsubscribeStream) unsubscribeStream();
            if (viewerPeerConnection) {
                viewerPeerConnection.close();
                viewerPeerConnection = null;
            }
            if(adInterval) clearInterval(adInterval);
            if(window.depositPollingInterval) clearInterval(window.depositPollingInterval);
            adInterval = null;
            unsubscribeChat = null;
            unsubscribeStream = null;
        }

        function renderStudioStream() {
            currentPageRender = renderStudioStream;
            const categoriesOptions = CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join('');
            return `
                <div class="flex flex-col lg:flex-row gap-6 h-full">
                    <div class="w-full lg:w-2/3 space-y-4"><h2 class="text-2xl font-bold" data-key="stream_dashboard">Stream Dashboard</h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                             <div><label class="font-semibold text-sm" data-key="stream_title">Stream Title</label><input id="stream-title-input" type="text" value="My awesome stream on Live Payout!" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></div>
                             <div><label class="font-semibold text-sm" data-key="category">Category</label><select id="stream-category-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2">${categoriesOptions}</select></div>
                        </div>
                         <div><label class="font-semibold text-sm" data-key="thumbnail_url">Thumbnail URL (Optional)</label><input id="stream-thumbnail-input" type="text" data-key-placeholder="thumbnail_placeholder" placeholder="https://example.com/image.png" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></div>
                        <div><label class="font-semibold text-sm" data-key="microphone">Microphone</label><select id="mic-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></select></div>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <button id="select-cam-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white p-3 rounded-lg flex items-center justify-center gap-2 transition-colors disabled:opacity-50" data-key="use_camera"><i data-lucide="camera"></i>Use Camera</button>
                            <button id="select-screen-btn" class="flex-1 purple-gradient-bg hover:opacity-90 text-white p-3 rounded-lg flex items-center justify-center gap-2 transition-colors disabled:opacity-50" data-key="share_screen"><i data-lucide="screen-share"></i>Share Screen</button>
                        </div>
                        <div class="bg-black p-2 rounded-lg">
                            <h3 class="font-semibold text-center mb-2 flex items-center justify-center gap-2" id="stream-status-container">
                                <span id="stream-status-text" data-key="preview">Preview</span><span id="studio-viewer-count" class="flex items-center gap-1 text-sm text-gray-400"></span><span id="stream-timer" class="font-mono"></span>
                            </h3><video id="local-video-preview" muted autoplay playsinline></video>
                        </div>
                    </div>
                    <div class="w-full lg:w-1/3 flex flex-col gap-4">
                         <div class="flex items-center justify-between"><h2 class="text-2xl font-bold" data-key="chat">Chat</h2></div>
                        <div id="studio-chat-messages" class="flex-grow bg-[var(--background-tertiary)] rounded-lg p-2 space-y-2 overflow-y-auto border border-[var(--border-color)] h-64 lg:h-auto"></div>
                        <div class="flex gap-4">
                            <button id="start-stream-btn" class="flex-1 purple-gradient-bg text-white font-bold p-3 rounded-lg flex items-center justify-center gap-2 disabled:opacity-50" disabled><i data-lucide="play-circle"></i><span data-key="start_stream">Start</span></button>
                            <button id="stop-stream-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold p-3 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-600 disabled:opacity-50" disabled><i data-lucide="stop-circle"></i><span data-key="stop_stream">Stop</span></button>
                        </div>
                    </div>
                </div>`;
        }
        
        function renderStudioAnalytics() {
            currentPageRender = renderStudioAnalytics;
            if (!currentUser) return `<div class="text-center">Loading data...</div>`;
            return `
                <h2 class="text-2xl font-bold mb-6" data-key="analytics_rewards">Analytics & Rewards</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                     <div class="bg-[var(--background-tertiary)] p-6 rounded-xl border border-[var(--border-color)] md:col-span-2">
                         <div class="flex items-center justify-between mb-4">
                            <h3 class="font-semibold text-lg" data-key="earnings_summary">Earnings Summary</h3>
                            <i data-lucide="award" class="w-6 h-6 text-purple-400"></i>
                        </div>
                        <div class="flex items-center gap-2 my-2">
                            <img src="${BIT_COIN_LOGO_URL}" class="w-10 h-10 rounded-full object-cover">
                            <p class="text-4xl font-bold">${currentUser.creatorRewardsBalance.toLocaleString()} <span class="text-purple-300">BIT</span></p>
                        </div>
                        <p class="text-xs text-[var(--text-secondary)] mt-4">${translations[currentLang].rewards_info.replace('%a', REWARD_AMOUNT.toLocaleString()).replace('%m', REWARD_INTERVAL_MINUTES)}</p>
                        <button id="transfer-rewards" class="w-full purple-gradient-bg hover:opacity-90 text-white font-bold py-3 rounded-lg transition-all mt-4 disabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" data-key="send_to_balance">Send to Main Balance</button>
                    </div>
                </div>
                <div class="mt-6"><img src="https://placehold.co/800x400/1e1e24/2a2a32?text=Performance+Charts" class="w-full rounded-lg"></div>`;
        }

        function attachAnalyticsListeners() {
            if (!currentUser) return;
            const transferBtn = document.getElementById("transfer-rewards");
            if(currentUser.creatorRewardsBalance <= 0) { transferBtn.disabled = true; }
            transferBtn.addEventListener("click", async () => {
                if(currentUser.creatorRewardsBalance <= 0) return;
                loader.classList.remove("hidden");
                const userRef = doc(db, "users", currentUser.walletAddress);
                const amount = currentUser.creatorRewardsBalance;
                
                try {
                    await runTransaction(db, async (t) => {
                        t.update(userRef, { 
                            bitBalance: increment(amount), 
                            creatorRewardsBalance: 0 
                        });
                        
                        const txCol = collection(db, "users", currentUser.walletAddress, "transactions");
                        t.set(doc(txCol), {
                            type: 'reward_transfer',
                            amount: amount,
                            timestamp: serverTimestamp(),
                            details: { from: 'creator_balance', to: 'main_balance' }
                        });
                    });
                    
                    showToast(translations[currentLang].rewards_transferred.replace('%a', amount.toLocaleString()));
                } catch (error) {
                    console.error("Error transferring rewards:", error);
                    showToast("Error al transferir recompensas.", true);
                } finally {
                    loader.classList.add("hidden");
                }
            });
        }

        async function saveProfile() {
            const newPicUrl = document.getElementById("profile-pic-url").value.trim();
            const newUsername = document.getElementById("username-input").value.trim();
            const updates = {};
            if (newPicUrl && newPicUrl !== currentUser.profilePicture) updates.profilePicture = newPicUrl;
            if (newUsername && newUsername !== currentUser.username) updates.username = newUsername;
            if (Object.keys(updates).length > 0) {
                loader.classList.remove("hidden");
                await updateDoc(doc(db, "users", currentUser.walletAddress), updates);
                showToast(translations[currentLang].profile_updated);
                loader.classList.add("hidden");
            }
        }

        const TOKEN_CONTRACT = "EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump";
        async function updateWithdrawalStatus() {
            const usdEquivalentDisplay = document.getElementById("usd-equivalent-display");
            const tokenPriceInfo = document.getElementById("token-price-info");
            const withdrawButton = document.getElementById("withdraw-button");
            const withdrawalInfoText = document.getElementById("withdrawal-info-text");
            if (!currentUser || !withdrawalInfoText) return;
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${TOKEN_CONTRACT}`);
                if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                const data = await response.json();
                const firstPair = data.pairs && data.pairs.length > 0 ? data.pairs[0] : null;
                const priceUsd = firstPair ? parseFloat(firstPair.priceUsd) : 0;
                if (firstPair && !isNaN(priceUsd)) {
                    const balanceUsd = currentUser.bitBalance * priceUsd;
                    if (tokenPriceInfo) tokenPriceInfo.textContent = `1 BIT \u2248 $${priceUsd.toFixed(6)} USD`;
                    if (usdEquivalentDisplay) usdEquivalentDisplay.textContent = `~ $${balanceUsd.toFixed(2)} USD`;
                } else {
                    if (usdEquivalentDisplay) usdEquivalentDisplay.textContent = `~ $---- USD`;
                }
                const canWithdraw = currentUser.bitBalance >= WITHDRAWAL_MINIMUM_BIT;
                if (withdrawButton) withdrawButton.disabled = !canWithdraw;
                if (canWithdraw) {
                    if(withdrawalInfoText) withdrawalInfoText.textContent = translations[currentLang].withdrawal_ready;
                } else {
                    const neededBits = WITHDRAWAL_MINIMUM_BIT - currentUser.bitBalance;
                    if(withdrawalInfoText) withdrawalInfoText.textContent = translations[currentLang].need_more_to_withdraw.replace('%a', neededBits.toLocaleString());
                }
            } catch (e) {
                console.error("Error fetching token price:", e);
                if (usdEquivalentDisplay) usdEquivalentDisplay.textContent = translations[currentLang].price_fetch_error;
                if (tokenPriceInfo) tokenPriceInfo.textContent = '';
                const canWithdraw = currentUser.bitBalance >= WITHDRAWAL_MINIMUM_BIT;
                if (withdrawButton) withdrawButton.disabled = !canWithdraw;
                if (!canWithdraw) {
                    const neededBits = WITHDRAWAL_MINIMUM_BIT - currentUser.bitBalance;
                    if (withdrawalInfoText) withdrawalInfoText.textContent = translations[currentLang].need_more_to_withdraw.replace('%a', neededBits.toLocaleString());
                } else {
                     if (withdrawalInfoText) withdrawalInfoText.textContent = translations[currentLang].withdrawal_ready;
                }
            }
        }
        
        async function requestWithdrawal() {
            const withdrawButton = document.getElementById("withdraw-button");
            const withdrawMessage = document.getElementById("withdraw-message");
            if (withdrawButton.disabled) return;
            loader.classList.remove("hidden");
            withdrawMessage.textContent = translations[currentLang].processing;
            try {
                const amountToWithdraw = currentUser.bitBalance;
                
                const userRef = doc(db, "users", currentUser.walletAddress);
                await runTransaction(db, async (t) => {
                    t.update(userRef, { bitBalance: 0 });
                    
                    const reqCol = collection(db, "withdrawalRequests");
                    t.set(doc(reqCol), {
                        userWallet: currentUser.walletAddress, 
                        username: currentUser.username, 
                        amount: amountToWithdraw, 
                        status: "pending", 
                        requestedAt: serverTimestamp()
                    });
                    
                    const txCol = collection(db, "users", currentUser.walletAddress, "transactions");
                    t.set(doc(txCol), {
                        type: 'withdrawal_request',
                        amount: -amountToWithdraw,
                        timestamp: serverTimestamp(),
                        details: { status: 'pending' }
                    });
                });

                withdrawMessage.textContent = translations[currentLang].withdrawal_requested;
                withdrawMessage.classList.add("text-green-500");
                showToast(translations[currentLang].withdrawal_requested_toast);
            } catch (error) {
                console.error("Error creating withdrawal request:", error);
                withdrawMessage.textContent = translations[currentLang].withdrawal_error;
                withdrawMessage.classList.add("text-red-500");
                await updateDoc(doc(db, "users", currentUser.walletAddress), { bitBalance: currentUser.bitBalance });
            } finally {
                loader.classList.add("hidden");
            }
        }

        async function setupFollowButton(streamerWallet) {
            const followBtn = document.getElementById('follow-btn');
            if (!currentUser) return;
            const myFollowingRef = doc(db, 'users', currentUser.walletAddress, 'following', streamerWallet);
            onSnapshot(myFollowingRef, (docSnap) => {
                followBtn.classList.remove('purple-gradient-bg', 'bg-transparent', 'border', 'border-[var(--brand-color-purple)]', 'text-[var(--brand-color-purple)]', 'bg-gray-700', 'hover:bg-gray-600');
                followBtn.classList.add('text-white');
                if (docSnap.exists()) {
                    followBtn.textContent = translations[currentLang].unfollow;
                    followBtn.classList.add('bg-transparent', 'border', 'border-[var(--brand-color-purple)]', 'text-[var(--brand-color-purple)]');
                    followBtn.classList.remove('text-white');
                } else {
                    followBtn.textContent = translations[currentLang].follow;
                    followBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                }
            });
            followBtn.onclick = async () => {
                if (!requireAuth()) return;
                const docSnap = await getDoc(myFollowingRef);
                const streamerFollowersRef = doc(db, 'users', streamerWallet, 'followers', currentUser.walletAddress);
                const myUserRef = doc(db, 'users', currentUser.walletAddress);
                const streamerUserRef = doc(db, 'users', streamerWallet);
                try {
                    const streamerUsername = ((await getDoc(streamerUserRef)).data() || {}).username || streamerWallet.substring(0,6);
                    if (docSnap.exists()) {
                        await runTransaction(db, async (t) => { t.delete(myFollowingRef); t.delete(streamerFollowersRef); t.update(myUserRef, { followingCount: increment(-1) }); t.update(streamerUserRef, { followersCount: increment(-1) }); });
                        showToast(translations[currentLang].unfollowed_user.replace('%s', streamerUsername));
                    } else {
                        await runTransaction(db, async (t) => { t.set(myFollowingRef, { followedAt: serverTimestamp() }); t.set(streamerFollowersRef, { followerAt: serverTimestamp() }); t.update(myUserRef, { followingCount: increment(1) }); t.update(streamerUserRef, { followersCount: increment(1) }); });
                        showToast(translations[currentLang].followed_user.replace('%s', streamerUsername));
                    }
                } catch (error) { console.error("Follow/unfollow error:", error); showToast(translations[currentLang].action_error); }
            };
        }
        
        async function setupSubscribeButton(streamerWallet) {
            const subBtn = document.getElementById('subscribe-btn');
            const subRef = doc(db, 'users', streamerWallet, 'subscribers', currentUser.walletAddress);
            const subSnap = await getDoc(subRef);
            if (subSnap.exists()) {
                subBtn.disabled = true;
                subBtn.innerHTML = `<i data-lucide="check"></i> <span data-key="subscribed">${translations[currentLang].subscribed}</span>`;
                lucide.createIcons();
            }
            subBtn.onclick = async () => {
                if (!requireAuth()) return;
                const subscriptionCost = 100;
                if (currentUser.bitBalance < subscriptionCost) return showToast(translations[currentLang].insufficient_bits_subscribe);
                loader.classList.remove('hidden');
                try {
                    const streamerUserRef = doc(db, "users", streamerWallet);
                    const streamerUsername = ((await getDoc(streamerUserRef)).data() || {}).username || streamerWallet.substring(0,6);
                    
                    await runTransaction(db, async (t) => {
                        const myUserRef = doc(db, "users", currentUser.walletAddress);
                        const myDoc = await t.get(myUserRef);
                        if (!myDoc.exists() || myDoc.data().bitBalance < subscriptionCost) throw "Insufficient balance.";
                        
                        t.update(myUserRef, { bitBalance: increment(-subscriptionCost) });
                        t.update(streamerUserRef, { creatorRewardsBalance: increment(subscriptionCost) });
                        t.set(subRef, { subscribedAt: serverTimestamp(), expiresAt: 'never' });
                        
                        const txTime = serverTimestamp();
                        const txColBuyer = collection(db, "users", currentUser.walletAddress, "transactions");
                        t.set(doc(txColBuyer), {
                            type: 'subscription_purchase',
                            amount: -subscriptionCost,
                            timestamp: txTime,
                            details: { toUser: streamerWallet, username: streamerUsername }
                        });
                        
                        const txColStreamer = collection(db, "users", streamerWallet, "transactions");
                        t.set(doc(txColStreamer), {
                            type: 'subscription_reward',
                            amount: subscriptionCost,
                            timestamp: txTime,
                            details: { fromUser: currentUser.walletAddress, username: currentUser.username }
                        });
                    });
                    
                    showToast(translations[currentLang].subscribed_to_user.replace('%s', streamerUsername));
                    subBtn.disabled = true;
                    subBtn.innerHTML = `<i data-lucide="check"></i> <span data-key="subscribed">${translations[currentLang].subscribed}</span>`;
                    lucide.createIcons();
                } catch (e) { console.error("Subscription transaction error: ", e); showToast(translations[currentLang].subscription_error); } finally { loader.classList.add('hidden'); }
            };
        }

        function setupVipEmojiPanel(streamerWallet) {
            const openBtn = document.getElementById('open-vip-emojis');
            const panel = document.getElementById('vip-emoji-panel');
            const chatInput = document.getElementById('chat-input');
            openBtn.onclick = () => panel.classList.toggle('hidden');
            panel.addEventListener('click', async (e) => {
                const button = e.target.closest('.vip-emoji-btn');
                if (button) {
                    if (!requireAuth()) return;
                    panel.classList.add('hidden');
                    const emoji = VIP_EMOJIS.find(em => em.id === button.dataset.emojiId);
                    const text = chatInput.value.trim();
                    if (!text) return showToast(translations[currentLang].superchat_no_text);
                    if (currentUser.bitBalance < emoji.price) return showToast(translations[currentLang].insufficient_bits_emoji.replace('%p', emoji.price));
                    loader.classList.remove('hidden');
                    try {
                        const streamerUserRef = doc(db, "users", streamerWallet);
                        const streamerUsername = ((await getDoc(streamerUserRef)).data() || {}).username || streamerWallet.substring(0,6);

                        await runTransaction(db, async (t) => {
                            const myUserRef = doc(db, "users", currentUser.walletAddress);
                            const myDoc = await t.get(myUserRef);
                            if (!myDoc.exists() || myDoc.data().bitBalance < emoji.price) throw "Insufficient balance.";
                            
                            t.update(myUserRef, { bitBalance: increment(-emoji.price) });
                            t.update(streamerUserRef, { creatorRewardsBalance: increment(emoji.price) });
                            
                            const txTime = serverTimestamp();
                            const txColBuyer = collection(db, "users", currentUser.walletAddress, "transactions");
                            t.set(doc(txColBuyer), {
                                type: 'vip_emoji_purchase',
                                amount: -emoji.price,
                                timestamp: txTime,
                                details: { toUser: streamerWallet, username: streamerUsername, emojiId: emoji.id }
                            });
                            
                            const txColStreamer = collection(db, "users", streamerWallet, "transactions");
                            t.set(doc(txColStreamer), {
                                type: 'vip_emoji_reward',
                                amount: emoji.price,
                                timestamp: txTime,
                                details: { fromUser: currentUser.walletAddress, username: currentUser.username, emojiId: emoji.id }
                            });
                        });
                        
                        await addDoc(collection(db, 'streams', streamerWallet, 'chat'), { text, userName: currentUser.username, userWallet: currentUser.walletAddress, userColor: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'), createdAt: serverTimestamp(), vipEmoji: { url: emoji.url, price: emoji.price } });
                        chatInput.value = '';
                    } catch(err) { console.error("Super Chat transaction error:", err); showToast(translations[currentLang].superchat_error); } finally { loader.classList.add('hidden'); }
                }
            });
        }

        let adInterval = null;
        function showAd() {
            const adContainer = document.getElementById('ad-container'), adWarning = document.getElementById('ad-warning'), adSlot = document.getElementById('ad-slot');
            if (!adContainer || !adWarning || !adSlot) return;
            adSlot.innerHTML = ''; adContainer.style.display = 'flex'; let countdown = 5;
            adWarning.textContent = translations[currentLang].ad_warning.replace('%s', countdown);
            const countdownInterval = setInterval(() => {
                countdown--; adWarning.textContent = translations[currentLang].ad_warning.replace('%s', countdown);
                if (countdown <= 0) {
                    clearInterval(countdownInterval); adWarning.textContent = translations[currentLang].ad_playing;
                    const oldAdScript = document.getElementById('dynamic-ad-script'); if(oldAdScript) oldAdScript.remove();
                    const scriptEl = document.createElement('script'); scriptEl.id = 'dynamic-ad-script'; document.body.appendChild(scriptEl);
                    (function(s) { s.dataset.zone = '9912761'; s.src = 'https://groleegni.net/vignette.min.js'; })(scriptEl);
                    setTimeout(() => { adContainer.style.display = 'none'; adSlot.innerHTML = ''; const adScriptToRemove = document.getElementById('dynamic-ad-script'); if (adScriptToRemove) adScriptToRemove.remove(); }, 20000); 
                }
            }, 1000);
        }

        let localStream = null, peerConnections = {}, viewersUnsubscribe = null, streamTimerInterval = null, rewardInterval = null, unsubscribeStudioChat = null;
        const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        async function attachStreamListeners() {
            document.getElementById('select-cam-btn').onclick = () => getMedia('camera');
            const selectScreenBtn = document.getElementById('select-screen-btn');
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                selectScreenBtn.onclick = () => getMedia('screen');
            } else { selectScreenBtn.disabled = true; selectScreenBtn.onclick = () => showToast('Screen sharing is not available.'); }
            document.getElementById('start-stream-btn').onclick = startStream;
            document.getElementById('stop-stream-btn').onclick = stopStream;
            const micSelect = document.getElementById('mic-select');
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                devices.filter(({ kind }) => kind === 'audioinput').forEach(({ deviceId, label }) => {
                    const option = document.createElement('option'); option.value = deviceId;
                    option.text = label || `${translations[currentLang].microphone} ${micSelect.options.length + 1}`;
                    micSelect.appendChild(option);
                });
            } catch(e) { console.error("Error enumerating devices:", e); }
            
            const studioChatMessages = document.getElementById('studio-chat-messages');
            if (studioChatMessages) {
                studioChatMessages.addEventListener('click', (e) => {
                    const modBtn = e.target.closest('.mod-user-btn');
                    if (modBtn) {
                        e.preventDefault();
                        const wallet = modBtn.dataset.wallet;
                        const name = modBtn.dataset.name;
                        if (wallet && name) {
                            showModModal(wallet, name);
                        }
                    }
                });
            }
        }

        async function getMedia(type) {
            try {
                if (localStream) localStream.getTracks().forEach(track => track.stop());
                const audioDeviceId = document.getElementById('mic-select').value;
                const constraints = { video: true, audio: { deviceId: audioDeviceId ? {exact: audioDeviceId} : undefined } };
                localStream = type === 'camera' ? await navigator.mediaDevices.getUserMedia(constraints) : await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                document.getElementById('local-video-preview').srcObject = localStream;
                document.getElementById('start-stream-btn').disabled = false;
            } catch (error) { console.error(`Error getting ${type}`, error); showToast(translations[currentLang].media_error); }
        }

        async function startStream() {
            if (!localStream) return showToast(translations[currentLang].no_video_source);
            const streamRef = doc(db, 'streams', currentUser.walletAddress);
            loader.classList.remove('hidden');
            try {
                await setDoc(streamRef, {
                    status: 'live', title: document.getElementById('stream-title-input').value, category: document.getElementById('stream-category-select').value, thumbnailUrl: document.getElementById('stream-thumbnail-input').value, streamerWallet: currentUser.walletAddress, streamerPic: currentUser.profilePicture, streamerUsername: currentUser.username, viewerCount: 0
                });
                viewersUnsubscribe = onSnapshot(collection(streamRef, 'viewers'), (snapshot) => {
                    updateDoc(streamRef, { viewerCount: snapshot.size });
                    const studioViewerCount = document.getElementById('studio-viewer-count');
                    if(studioViewerCount) { studioViewerCount.innerHTML = `<i data-lucide="users" class="w-4 h-4"></i> ${snapshot.size}`; lucide.createIcons(); }
                    snapshot.docChanges().forEach(async (change) => {
                        const viewerUid = change.doc.id, viewerData = change.doc.data();
                        if (change.type === 'added' && viewerData.offer) {
                            peerConnections[viewerUid] = new RTCPeerConnection(iceServers);
                            localStream.getTracks().forEach(track => peerConnections[viewerUid].addTrack(track, localStream));
                            peerConnections[viewerUid].onicecandidate = e => e.candidate && addDoc(collection(change.doc.ref, 'iceCandidates'), e.candidate.toJSON());
                            onSnapshot(collection(change.doc.ref, 'iceCandidatesFromViewer'), snap => snap.docChanges().forEach(c => c.type === 'added' && peerConnections[viewerUid].addIceCandidate(new RTCIceCandidate(c.doc.data()))));
                            await peerConnections[viewerUid].setRemoteDescription(new RTCSessionDescription(viewerData.offer));
                            const answer = await peerConnections[viewerUid].createAnswer();
                            await peerConnections[viewerUid].setLocalDescription(answer);
                            await updateDoc(change.doc.ref, { answer });
                        }
                        if (change.type === 'removed' && peerConnections[viewerUid]) { peerConnections[viewerUid].close(); delete peerConnections[viewerUid]; }
                    });
                });
                const studioChatMessages = document.getElementById('studio-chat-messages');
                const chatRef = collection(streamRef, 'chat');
                unsubscribeStudioChat = onSnapshot(query(chatRef, orderBy("createdAt", "desc"), limit(50)), (snapshot) => {
                    snapshot.docChanges().reverse().forEach(change => {
                        if (change.type === "added") {
                            const msg = change.doc.data(), msgEl = document.createElement('div');
                            const userNameBtn = `<button class="font-semibold mod-user-btn hover:underline" style="color: ${msg.userColor || '#FFF'}" data-wallet="${msg.userWallet}" data-name="${msg.userName}">${msg.userName}</button>`;
                            
                            if (msg.vipEmoji) {
                                msgEl.className = 'super-chat text-xs'; 
                                msgEl.innerHTML = `<div class="flex items-center gap-1 mb-1"><img src="${msg.vipEmoji.url}" class="w-6 h-6"><div class="font-bold">${userNameBtn} ${translations[currentLang].sent} ${msg.vipEmoji.price} BIT</div></div><p>${msg.text}</p>`;
                            } else if (msg.userWallet === 'system') {
                                msgEl.className = 'text-xs p-1 font-bold';
                                msgEl.style.color = msg.userColor || '#FF0000'; // Rojo por defecto
                                msgEl.innerHTML = msg.text;
                            } else { 
                                msgEl.className = 'text-xs p-1'; 
                                msgEl.innerHTML = `${userNameBtn}: ${msg.text}`; 
                            }
                            studioChatMessages.appendChild(msgEl);
                        }
                    });
                    studioChatMessages.scrollTop = studioChatMessages.scrollHeight;
                });
                document.getElementById('stream-status-text').innerHTML = `<span class="text-red-500 font-bold flex items-center gap-2"><div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>LIVE</span>`;
                document.getElementById('start-stream-btn').disabled = true; document.getElementById('stop-stream-btn').disabled = false;
                let startTime = Date.now(), timerEl = document.getElementById('stream-timer');
                streamTimerInterval = setInterval(() => { const e=Date.now()-startTime,s=Math.floor(e/1e3%60).toString().padStart(2,'0'),m=Math.floor(e/6e4%60).toString().padStart(2,'0'),h=Math.floor(e/36e5).toString().padStart(2,'0'); if(timerEl)timerEl.textContent=`${h}:${m}:${s}`}, 1000);
                let lastRewardTimeInMinutes = 0;
                rewardInterval = setInterval(async () => {
                    const currentMinutes = Math.floor((Date.now() - startTime) / 60000);
                    if (currentMinutes >= lastRewardTimeInMinutes + REWARD_INTERVAL_MINUTES) {
                        lastRewardTimeInMinutes += REWARD_INTERVAL_MINUTES;
                        const amount = REWARD_AMOUNT;
                        
                        await runTransaction(db, async (t) => {
                            const userRef = doc(db, "users", currentUser.walletAddress);
                            t.update(userRef, { creatorRewardsBalance: increment(amount) });
                            
                            const txCol = collection(db, "users", currentUser.walletAddress, "transactions");
                            t.set(doc(txCol), {
                                type: 'stream_reward',
                                amount: amount,
                                timestamp: serverTimestamp(),
                                details: { minutes: lastRewardTimeInMinutes }
                            });
                        });
                        
                        showToast(translations[currentLang].reward_notification.replace('%a', amount.toLocaleString()).replace('%m', lastRewardTimeInMinutes));
                    }
                }, 15000);
                if(adInterval) clearInterval(adInterval);
                adInterval = setInterval(showAd, 120000);
                showToast(translations[currentLang].stream_started);
            } catch (error) { console.error("Error starting stream:", error); showToast(translations[currentLang].stream_start_error); stopStream(); } finally { loader.classList.add('hidden'); }
        }

        async function stopStream() {
            if (streamTimerInterval) clearInterval(streamTimerInterval); if (rewardInterval) clearInterval(rewardInterval); if (adInterval) clearInterval(adInterval);
            if (localStream) localStream.getTracks().forEach(track => track.stop());
            if (viewersUnsubscribe) viewersUnsubscribe(); if (unsubscribeStudioChat) unsubscribeStudioChat();
            Object.values(peerConnections).forEach(pc => pc.close());
            localStream=null;streamTimerInterval=null;rewardInterval=null;adInterval=null;peerConnections={};
            if (!currentUser) return;
            const streamRef = doc(db, 'streams', currentUser.walletAddress);
            try {
                for(const collPath of ['viewers', 'chat', 'bans']) {
                    const collRef = collection(streamRef, collPath);
                    const snapshot = await getDocs(collRef); 
                    if(!snapshot.empty) { 
                        const batch = writeBatch(db); 
                        snapshot.forEach(doc => batch.delete(doc.ref)); 
                        await batch.commit(); 
                    }
                }
                await deleteDoc(streamRef);
            } catch(error) { console.error("Error cleaning up stream:", error); await deleteDoc(streamRef).catch(()=>{}); }
            const studioUI = document.getElementById('studio-content');
            if(studioUI) {
                const statusText = studioUI.querySelector('#stream-status-text'); if (statusText) statusText.textContent = translations[currentLang].preview;
                const timerEl = studioUI.querySelector('#stream-timer'); if (timerEl) timerEl.textContent = '';
                const viewerCountEl = studioUI.querySelector('#studio-viewer-count'); if (viewerCountEl) viewerCountEl.innerHTML = '';
                studioUI.querySelector('#start-stream-btn').disabled = true; studioUI.querySelector('#stop-stream-btn').disabled = true;
                const videoPreview = studioUI.querySelector('#local-video-preview'); if(videoPreview) videoPreview.srcObject = null;
            }
            showToast(translations[currentLang].stream_stopped);
        }

        async function joinStream(streamerWallet) {
            viewerPeerConnection = new RTCPeerConnection(iceServers);
            const remoteVideo = document.getElementById('remote-video'), videoOverlay = document.getElementById('video-overlay');
            const viewerRef = doc(db, 'streams', streamerWallet, 'viewers', auth.currentUser ? auth.currentUser.uid : `guest_${Date.now()}`);
            const iceCandidateBuffer = [];
            viewerPeerConnection.oniceconnectionstatechange = () => {
                if(videoOverlay) videoOverlay.textContent = `Status: ${viewerPeerConnection.iceConnectionState}`;
                 if(viewerPeerConnection.iceConnectionState === 'connected' || viewerPeerConnection.iceConnectionState === 'completed'){
                    if(videoOverlay) videoOverlay.style.display = 'none'; if(remoteVideo) remoteVideo.classList.add('opacity-100');
                    if(adInterval) clearInterval(adInterval); adInterval = setInterval(showAd, 120000);
                }
            };
            viewerPeerConnection.ontrack = e => { if (e.streams && e.streams[0] && remoteVideo.srcObject !== e.streams[0]) remoteVideo.srcObject = e.streams[0]; };
            if (currentUser) {
                viewerPeerConnection.onicecandidate = e => e.candidate && addDoc(collection(viewerRef, 'iceCandidatesFromViewer'), e.candidate.toJSON());
                onSnapshot(collection(viewerRef, 'iceCandidates'), s => s.docChanges().forEach(change => {
                    if (change.type === 'added') { const candidate = new RTCIceCandidate(change.doc.data()); if (viewerPeerConnection.currentRemoteDescription) viewerPeerConnection.addIceCandidate(candidate); else iceCandidateBuffer.push(candidate); }
                }));
            }
            const offer = await viewerPeerConnection.createOffer({offerToReceiveVideo: true, offerToReceiveAudio: true});
            await viewerPeerConnection.setLocalDescription(offer);
            await setDoc(viewerRef, { offer });
            onSnapshot(viewerRef, async (docSnap) => {
                const data = docSnap.data();
                if (data && data.answer && !viewerPeerConnection.currentRemoteDescription) {
                    await viewerPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    iceCandidateBuffer.forEach(c => viewerPeerConnection.addIceCandidate(c)); iceCandidateBuffer.length = 0;
                }
            });
            const leaveStream = () => { if(viewerPeerConnection) { viewerPeerConnection.close(); deleteDoc(viewerRef).catch(()=>{}); } if(adInterval) clearInterval(adInterval); };
            window.addEventListener('pagehide', leaveStream, { once: true });
        }
        
        window.onbeforeunload = () => { if (Object.keys(peerConnections).length > 0) stopStream(); }
        
        function setupModModalListeners() {
            if (!modModal) return;
            modModal.addEventListener('click', (e) => { if (e.target === modModal) hideModModal(); });
            modModalCancel.addEventListener('click', hideModModal);
            modModalContent.addEventListener('click', (e) => {
                const actionBtn = e.target.closest('.mod-action-btn');
                if (actionBtn) {
                    const durationStr = actionBtn.dataset.duration;
                    let durationMinutes = 0;
                    if (durationStr === 'perma') durationMinutes = null;
                    else durationMinutes = parseInt(durationStr, 10);
                    if (modModalTargetUser.wallet) banUser(currentUser.walletAddress, modModalTargetUser.wallet, modModalTargetUser.name, durationMinutes);
                    hideModModal();
                }
            });
        }
        
        function showModModal(userWallet, userName) {
            if (!modModal || !modModalUsername) return;
            if (userWallet === currentUser.walletAddress) return;
            modModalTargetUser = { wallet: userWallet, name: userName };
            modModalUsername.textContent = `Baneando a: ${userName}`;
            modModal.classList.remove('hidden');
            setTimeout(() => {
                modModal.classList.remove('opacity-0', 'scale-95');
                modModalContent.classList.remove('scale-100');
                modModalContent.classList.add('scale-100');
            }, 10);
        }

        function hideModModal() {
            if (!modModal) return;
            modModal.classList.add('opacity-0', 'scale-95');
            modModalContent.classList.add('scale-95');
            setTimeout(() => {
                modModal.classList.add('hidden');
                modModalTargetUser = { wallet: null, name: null };
            }, 200);
        }
        
        async function banUser(streamerWallet, bannedUserWallet, bannedUserName, durationMinutes) {
            if (!streamerWallet || !bannedUserWallet) return;
            
            const banRef = doc(db, 'streams', streamerWallet, 'bans', bannedUserWallet);
            let expiresAt = null;
            let banMessage = '';
            
            if (durationMinutes === null) {
                expiresAt = null;
                banMessage = `Usuario ${bannedUserName} ha sido baneado permanentemente.`;
            } else {
                const expiresDate = new Date(Date.now() + durationMinutes * 60 * 1000);
                expiresAt = expiresDate;
                banMessage = `Usuario ${bannedUserName} ha sido baneado por ${durationMinutes} minuto(s).`;
            }
            
            try {
                await setDoc(banRef, {
                    bannedAt: serverTimestamp(),
                    expiresAt: expiresAt,
                    bannedBy: streamerWallet,
                    userName: bannedUserName
                });
                showToast(banMessage);
                
                const chatRef = collection(db, 'streams', streamerWallet, 'chat');
                await addDoc(chatRef, {
                    text: `[MOD] ${banMessage}`,
                    userName: 'Sistema',
                    userWallet: 'system',
                    userColor: '#E53E3E', // Rojo (Tailwind red-600)
                    createdAt: serverTimestamp()
                });
                
            } catch (error) {
                console.error("Error al banear usuario:", error);
                showToast("Error al aplicar el ban.", true);
            }
        }


        const translations = {
            en: {
                explore: "Explore", categories: "Categories", creator: "Creator", creator_studio: "Creator Studio", recommended_channels: "Recommended Channels", followers: "followers", save: "Save", logout: "Log Out", processing: "Processing...", action_error: "Error processing action.", ad_warning: "An ad will appear in %s...", ad_playing: "Ad is playing...", welcome_to: "Welcome to", login_prompt: "Enter with your public Solana wallet address to start.", login_button: "Enter / Create Account", explore_title: "Explore Live Channels", categories_title: "Explore Categories", no_one_live: "No one is live in the '%s' category right now.", connecting_stream: "Connecting to stream...", live_chat: "Live Chat", chat_placeholder: "Send a message...", follow: "Follow", unfollow: "Unfollow", subscribe: "Subscribe", subscribed: "Subscribed", stream_ended: "The stream has ended.", sent: "sent", settings: "Settings", language: "Language", edit_profile: "Edit Profile", balance_withdrawal: "Balance & Withdrawal", current_balance: "Your Current Balance", withdrawal_minimum_bit: "You need a minimum of %a BIT to withdraw.", request_withdrawal: "Request Withdrawal", need_more_to_withdraw: "You need %a more BIT to withdraw.", withdrawal_ready: "You can request your withdrawal now.", withdrawal_requested: "Withdrawal request sent!", withdrawal_requested_toast: "Your withdrawal request has been sent.", withdrawal_error: "Error sending request.", profile_updated: "Profile updated successfully.", username: "Username", profile_pic_url: "Profile Picture URL", save_changes: "Save Changes", price_fetch_error: "Could not fetch price.", cannot_calculate_withdrawal: "Cannot calculate withdrawal requirements.", stream_dashboard: "Stream Dashboard", stream_title: "Stream Title", category: "Category", thumbnail_url: "Thumbnail URL (Optional)", thumbnail_placeholder: "https://example.com/image.png", microphone: "Microphone", use_camera: "Use Camera", share_screen: "Share Screen", preview: "Preview", chat: "Chat", start_stream: "Start", stop_stream: "Stop", analytics_rewards: "Analytics & Rewards", earnings_summary: "Earnings Summary", accumulated_rewards: "Accumulated Rewards", rewards_info: "You earn %a BIT for every %m minutes of streaming.", send_to_balance: "Send to Main Balance", followed_user: "You are now following %s.", unfollowed_user: "You have unfollowed %s.", insufficient_bits_subscribe: "You don't have enough BITs to subscribe.", subscribed_to_user: "You have subscribed to %s for 100 BIT", subscription_error: "Error processing subscription.", superchat_no_text: "Write a message to send with your VIP emoji.", insufficient_bits_emoji: "You need %p BIT to send this emoji.", superchat_error: "Error sending Super Chat.", media_error: "Could not access camera/screen.", no_video_source: "First select a video source.", stream_started: "Stream started!", stream_start_error: "Permission error. Could not start stream.", stream_stopped: "Stream stopped.", reward_notification: "+%a BIT for streaming %m minutes!", rewards_transferred: "%a BIT transferred to your balance.",
                transaction_history: "Transaction History",
                no_transactions: "No transactions yet.",
                you_are_banned: "You are banned from this chat.",
                tx_deposit: "Deposit",
                tx_withdrawal_request: "Withdrawal Request",
                tx_subscription_purchase: "Subscription",
                tx_subscription_reward: "Subscription",
                tx_vip_emoji_purchase: "VIP Emoji",
                tx_vip_emoji_reward: "VIP Emoji",
                tx_reward_transfer: "Rewards Transfer",
                tx_stream_reward: "Stream Reward",
            },
            es: {
                explore: "Explorar", categories: "Categorías", creator: "Creador", creator_studio: "Estudio del Creador", recommended_channels: "Canales Recomendados", followers: "seguidores", save: "Guardar", logout: "Cerrar Sesión", processing: "Procesando...", action_error: "Error al procesar la acción.", ad_warning: "Un anuncio aparecerá en %s...", ad_playing: "Anuncio en curso...", welcome_to: "Bienvenido a", login_prompt: "Ingresa con tu dirección de wallet pública de Solana para empezar.", login_button: "Entrar / Crear Cuenta", explore_title: "Explorar Canales en Vivo", categories_title: "Explorar Categorías", no_one_live: "No hay nadie en vivo en la categoría '%s' en este momento.", connecting_stream: "Conectando al stream...", live_chat: "Chat en Vivo", chat_placeholder: "Escribe un mensaje...", follow: "Seguir", unfollow: "Dejar de Seguir", subscribe: "Suscribirse", subscribed: "Suscrito", stream_ended: "La transmisión ha finalizado.", sent: "envió", settings: "Configuración", language: "Idioma", edit_profile: "Editar Perfil", balance_withdrawal: "Balance y Retiros", current_balance: "Tu Saldo Actual", withdrawal_minimum_bit: "Necesitas un mínimo de %a BIT para retirar.", request_withdrawal: "Solicitar Retiro", need_more_to_withdraw: "Te faltan %a BIT para poder retirar.", withdrawal_ready: "Ya puedes solicitar tu retiro.", withdrawal_requested: "¡Solicitud de retiro enviada!", withdrawal_requested_toast: "Tu solicitud de retiro ha sido enviada.", withdrawal_error: "Error al enviar la solicitud.", profile_updated: "Perfil actualizado correctamente.", username: "Nombre de usuario", profile_pic_url: "URL de foto de perfil", save_changes: "Guardar Cambios", price_fetch_error: "No se pudo obtener el precio.", cannot_calculate_withdrawal: "No se pueden calcular los requisitos de retiro.", stream_dashboard: "Panel de Transmisión", stream_title: "Título del Stream", category: "Categoría", thumbnail_url: "URL de la Miniatura (Opcional)", thumbnail_placeholder: "https://ejemplo.com/imagen.png", microphone: "Micrófono", use_camera: "Usar Cámara", share_screen: "Compartir Pantalla", preview: "Vista Previa", chat: "Chat", start_stream: "Iniciar", stop_stream: "Detener", analytics_rewards: "Analíticas y Recompensas", earnings_summary: "Resumen de Ganancias", accumulated_rewards: "Recompensas Acumuladas", rewards_info: "Ganas %a BIT por cada %m minutos de transmisión.", send_to_balance: "Enviar a Balance Principal", followed_user: "Ahora sigues a %s.", unfollowed_user: "Has dejado de seguir a %s.", insufficient_bits_subscribe: "No tienes suficientes BITs para suscribirte.", subscribed_to_user: "Te has suscrito a %s por 100 BIT", subscription_error: "Error al procesar la suscripción.", superchat_no_text: "Escribe un mensaje para enviarlo con tu emoji VIP.", insufficient_bits_emoji: "Necesitas %p BIT para enviar este emoji.", superchat_error: "Error al enviar el Super Chat.", media_error: "No se pudo acceder a la cámara/pantalla.", no_video_source: "Primero selecciona una fuente de video.", stream_started: "¡Has iniciado la transmisión!", stream_start_error: "Error de permisos. No se pudo iniciar el stream.", stream_stopped: "Transmisión detenida.", reward_notification: "¡+%a BIT por transmitir %m minutos!", rewards_transferred: "%a BIT transferidos a tu balance.",
                transaction_history: "Historial de Transacciones",
                no_transactions: "Aún no hay transacciones.",
                you_are_banned: "Estás baneado de este chat.",
                tx_deposit: "Depósito",
                tx_withdrawal_request: "Solicitud de Retiro",
                tx_subscription_purchase: "Suscripción",
                tx_subscription_reward: "Suscripción",
                tx_vip_emoji_purchase: "Emoji VIP",
                tx_vip_emoji_reward: "Emoji VIP",
                tx_reward_transfer: "Transferencia de Recompensa",
                tx_stream_reward: "Recompensa de Stream",
            }
        };

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-key]').forEach(el => {
                const key = el.dataset.key; if(translations[lang][key]) el.textContent = translations[lang][key];
            });
             document.querySelectorAll('[data-key-placeholder]').forEach(el => {
                const key = el.dataset.keyPlaceholder; if(translations[lang][key]) el.placeholder = translations[lang][key];
            });
        }
        
        // --- INICIALIZACIÓN ---
        setInterval(updateWithdrawalStatus, 30000);
        loader.classList.remove('hidden');
    </script>
</body>
</html>