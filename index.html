<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="monetag" content="2dc4448d78fbcf7944504727860de63e">
    <title>Live Payout - Tu Plataforma de Streaming</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="icon" type="image/jpeg" href="https://i.postimg.cc/4xL1nYWJ/android-chrome-512x512.png">

    <!-- <link rel="manifest" href="/site.webmanifest"> --> 
    
    <!-- Scripts de Solana y QR restaurados y actualizados -->
    <script src="https://unpkg.com/@solana/web3.js@1.81.0/lib/index.iife.min.js" async></script>
    <!-- SPL Token ya no es estrictamente necesario para enviar SOL, pero puede ser útil si se añade lógica de tokens después -->
    <!-- <script src="https://unpkg.com/@solana/spl-token@0.4.7/lib/index.iife.min.js" async></script> --> 
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js" async></script>

    <style>
        :root {
            --brand-color-1: #4ade80; /* green */
            --brand-color-2: #3b82f6; /* blue */
            --brand-color-purple: #8347dd;
            --brand-color-purple-dark: #8347dd;
            --background-primary: #0D0D10;
            --background-secondary: #141418;
            --background-tertiary: #1E1E24;
            --border-color: #2a2a32;
            --text-primary: #EAEAEA;
            --text-secondary: #A0A0B0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-primary);
            color: var(--text-primary);
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--background-secondary); }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        
        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        .animate-slide-in { animation: slideIn 0.5s cubic-bezier(0.25, 1, 0.5, 1); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .brand-gradient-text {
            background: linear-gradient(90deg, var(--brand-color-purple-dark), var(--brand-color-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .purple-gradient-bg {
             background: linear-gradient(90deg, var(--brand-color-purple-dark), var(--brand-color-purple));
        }
        .btn-glow {
            box-shadow: 0 0 5px var(--brand-color-purple), 0 0 10px var(--brand-color-purple);
        }
        .nav-link.active {
            background-color: var(--background-tertiary);
            color: white;
            font-weight: 600;
        }
        .nav-link.active i {
            color: var(--brand-color-purple);
        }
        video {
            width: 100%;
            background-color: black;
            border-radius: 0.75rem;
        }
        .member-badge {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            margin-right: 0.25rem;
            vertical-align: text-bottom;
        }
        .super-chat {
            background: linear-gradient(45deg, #1e3a8a, #4c1d95);
            border: 1px solid #3b82f6;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
        }
        .category-card img {
            aspect-ratio: 3 / 4;
            object-fit: cover;
        }
         .spinner-deposit {
            border-top-color: #8347dd;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
         /* Estilo para copiar texto (ya no necesario para este método) */
        /* .copyable-text { ... } */
    </style>
</head>
<body class="overflow-y-auto">

    <div id="sidebar-backdrop" class="fixed inset-0 bg-black/50 z-30 hidden md:hidden"></div>

    <div id="app-container" class="h-screen w-screen flex flex-col transition-opacity duration-500 opacity-0">

        <header class="bg-gradient-to-b from-[#18181c] to-[var(--background-secondary)] h-16 flex items-center justify-between px-4 md:px-6 border-b border-[var(--border-color)] z-20 flex-shrink-0">
            <div class="flex items-center gap-4">
                <button id="back-button" class="hidden p-2 -ml-2 rounded-md text-[var(--text-secondary)] hover:bg-[var(--background-tertiary)] md:hidden">
                    <i data-lucide="arrow-left"></i>
                </button>
                <button id="mobile-menu-btn" class="md:hidden p-2 -ml-2 rounded-md text-[var(--text-secondary)] hover:bg-[var(--background-tertiary)]">
                    <i data-lucide="menu" id="mobile-menu-icon"></i>
                </button>
                <a href="#" class="flex items-center nav-action" data-target="explore">
                    <img src="https://i.postimg.cc/50KvH8vD/log-peque.png" alt="Live Payout Logo" class="w-10 h-10 rounded-full">
                </a>
                <div class="hidden md:flex items-center gap-2 text-[var(--text-secondary)]">
                    <a href="#" class="nav-link nav-action px-3 py-2 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-all flex items-center gap-2" data-target="explore" data-key="explore"><i data-lucide="compass"></i>Explore</a>
                    <a href="#" class="nav-link nav-action px-3 py-2 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-all flex items-center gap-2" data-target="categories" data-key="categories"><i data-lucide="layout-grid"></i>Categories</a>
                </div>
            </div>
            <div id="user-profile-area" class="flex items-center gap-2 md:gap-4">
                <!-- Se rellena dinámicamente -->
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <aside id="sidebar" class="fixed top-0 left-0 h-full w-64 bg-[var(--background-secondary)] flex flex-col z-40 transform -translate-x-full transition-transform duration-300 md:relative md:translate-x-0 md:border-r md:border-[var(--border-color)] md:flex-shrink-0">
                <div class="p-4 border-b border-[var(--border-color)] md:hidden">
                    <a href="#" class="flex items-center gap-2 nav-action" data-target="explore">
                        <img src="https://i.postimg.cc/50KvH8vD/log-peque.png" alt="Live Payout Logo" class="w-8 h-8 rounded-full">
                        <span class="font-bold text-lg">Live Payout</span>
                    </a>
                </div>
                <nav class="flex flex-col space-y-2 p-4 md:p-0 md:mt-4">
                    <div class="md:hidden">
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-colors" data-target="explore" data-key="explore"><i data-lucide="compass" class="w-5 h-5"></i>Explore</a>
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-3 py-2.5 rounded-lg hover:bg-[var(--background-tertiary)] hover:text-white transition-colors" data-target="categories" data-key="categories"><i data-lucide="layout-grid" class="w-5 h-5"></i>Categories</a>
                        <div class="my-2 border-t border-[var(--border-color)]"></div>
                    </div>
                    <div id="creator-section">
                        <h3 class="px-3 text-sm font-semibold text-[var(--text-secondary)] uppercase tracking-wider" data-key="creator">Creator</h3>
                        <a href="#" class="nav-link nav-action flex items-center gap-3 px-4 py-3 rounded-xl transition-all duration-300 bg-[var(--background-tertiary)] border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] hover:shadow-[0_0_15px_rgba(167,139,250,0.4)]" data-target="studio">
                            <img src='https://i.postimg.cc/PxTt1gVn/7219b8450aa254b2d47645e0660295c1-icono-o-logotipo-de-camara-de-video.png' class='w-5 h-5 flex-shrink-0' alt='Creator Studio Icon'>
                            <span data-key="creator_studio">Creator Studio</span>
                        </a>
                    </div>
                </nav>
                <div class="my-4 border-t border-[var(--border-color)]"></div>
                <div class="px-4 md:px-0 flex-1 overflow-y-auto">
                  <h3 class="px-3 text-sm font-semibold text-[var(--text-secondary)] uppercase tracking-wider mb-2" data-key="recommended_channels">Recommended Channels</h3>
                  <div id="recommended-channels" class="space-y-3">
                      <!-- Canales recomendados se cargan aquí -->
                  </div>
                </div>
            </aside>

            <main id="main-content" class="flex-1 bg-[var(--background-primary)] flex flex-col overflow-y-auto">
                <!-- Contenido por defecto: Explorar -->
            </main>
        </div>
    </div>

    <div id="login-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in hidden">
        <div class="bg-[var(--background-secondary)] p-8 rounded-2xl shadow-2xl w-full max-w-md border border-[var(--border-color)] text-center transform transition-all duration-300 scale-95">
            <img src="https://i.postimg.cc/d1N7CQs2/photo-2025-09-19-11-13-33-2.jpg" alt="Logo" class="w-24 h-24 rounded-full mx-auto mb-4">
            <h1 class="text-4xl font-extrabold mb-4">
                <span data-key="welcome_to">Welcome to</span> 
                <span style="color: var(--brand-color-purple);">Live</span><span class="text-white">Payout</span>
            </h1>
            <p class="text-[var(--text-secondary)] mb-8" data-key="login_prompt">Enter with your public Solana wallet address to start.</p>
            <form id="login-form" class="space-y-4">
                <input type="text" id="wallet-address" placeholder="Ej: 5x...yZ" class="w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-1)] transition-all">
                <button type="submit" class="w-full purple-gradient-bg text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 hover:shadow-lg hover:btn-glow" data-key="login_button">
                    Enter / Create Account
                </button>
            </form>
            <p id="login-error" class="text-red-500 mt-4 text-sm h-5"></p>
        </div>
    </div>

    <div id="loader" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]">
        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-[var(--brand-color-purple)]"></div>
    </div>
    
    <div id="toast" class="fixed bottom-8 right-8 bg-green-600 text-white py-3 px-6 rounded-lg shadow-xl transform translate-y-20 opacity-0 transition-all duration-500 z-[100]">
        <p id="toast-message"></p>
    </div>

    <div id="ad-container" class="fixed inset-0 bg-black/90 z-[200] flex flex-col items-center justify-center text-white text-2xl hidden">
        <p id="ad-warning" class="mb-4 text-center font-bold"></p>
        <div id="ad-slot" class="w-full max-w-lg h-auto flex items-center justify-center"></div>
    </div>

    <script type="module">
        // --- Imports (deben estar en el nivel superior) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, updateDoc, increment, deleteDoc, getDocs, query, where, writeBatch, orderBy, limit, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Esperar a que el DOM esté cargado ---
        window.addEventListener('DOMContentLoaded', () => {
            
            // --- Mover todas las variables y lógica aquí dentro ---
            const firebaseConfig = {
                apiKey: "AIzaSyACz8EaihKTwAQHAnNCZJ-k8WxF1BDUOGs",
                authDomain: "livep-d622a.firebaseapp.com",
                projectId: "livep-d622a",
                storageBucket: "livep-d622a.firebasestorage.app",
                messagingSenderId: "257830156699",
                appId: "1:257830156699:web:30f1b92479ea035d4ac93e",
                measurementId: "G-EHBX5PD4G4"
            };
            
            const CATEGORIES = ['Just Chatting', 'Crypto Raiders', 'Axie Infinity', 'Star Atlas', 'Decentraland', 'The Sandbox', 'Gods Unchained', 'Music', 'Gaming', 'DeFi'];
            const CATEGORY_IMAGES = {
                'Just Chatting': 'https://i.scdn.co/image/ab6765630000ba8a1b9084981ea8acabb928955b', 'Crypto Raiders': 'https://assets.gam3s.gg/crypto_raiders_cover_3156b1065c/crypto_raiders_cover_3156b1065c.png', 'Axie Infinity': 'https://cdn.axieinfinity.com/axieinfinity-website/branding/axie-infinity-logo.png', 'Star Atlas': 'https://s2.coinmarketcap.com/static/img/coins/200x200/11212.png', 'Decentraland': 'https://www.shutterstock.com/image-vector/vector-image-crypto-currency-logo-600nw-2109327635.jpg', 'The Sandbox': 'https://altcoinsbox.com/wp-content/uploads/2023/03/full-the-sandbox-logo.webp', 'Gods Unchained': 'https://cdn1.epicgames.com/spt-assets/0668c386b36843ee816eccaa027005a8/gods-unchained-1cime.jpg', 'Music': 'https://png.pngtree.com/element_our/sm/20180415/sm_5ad31d9b53530.jpg', 'Gaming': 'https://img.freepik.com/vector-gratis/plantilla-logotipo-juegos-degradados_52683-132733.jpg?semt=ais_incoming&w=740&q=80', 'DeFi': 'https://images-platform.99static.com/DVhnqMGIzJRSQ_Jm4MxWYDGEVYg=/178x53:1458x1333/500x500/top/smart/99designs-contests-attachments/129/129813/attachment_129813968'
            };
            const VIP_EMOJIS = [
                { id: 'penguinsip', url: 'https://i.postimg.cc/DwVTxSBC/40196-penguinsip.gif', price: 20 }, { id: 'pinguin', url: 'https://i.postimg.cc/VLmTvXZP/45541-pinguin.gif', price: 20 }, { id: 'minecraft', url: 'https://i.postimg.cc/Lss1xyx3/403691-minecraft.png', price: 25 }, { id: 'pengubitcoin', url: 'https://i.postimg.cc/tCBrgwVF/42410-pengubitcoin.gif', price: 30 }, { id: 'smart_vegeta', url: 'https://i.postimg.cc/FH2Vd4Fk/793771-smart-vegeta.png', price: 30 }, { id: 'mewgrey', url: 'https://i.postimg.cc/jjWjWB8m/44097-mewgrey.gif', price: 35 }, { id: 'peperain', url: 'https://i.postimg.cc/85CcTF8R/93659-pepemoneyrain.gif', price: 40 }, { id: 'pepemonster', url: 'https://i.postimg.cc/P5z5ZbTb/345529-pepemonster.png', price: 40 }, { id: 'star', url: 'https://i.postimg.cc/fTwT7V2x/990874-star.gif', price: 45 }, { id: 'pepecard', url: 'https://i.postimg.cc/ryr0sr0j/761219-pepe-credit-card.gif', price: 50 }, { id: 'pepecry', url: 'https://i.postimg.cc/sXZXMkXx/471114-pepecry.png', price: 50 }, { id: 'pepesipspin', url: 'https://i.postimg.cc/T2QX6C0D/75754-pepesipspin.gif', price: 55 }
            ];
            const REWARD_INTERVAL_MINUTES = 5;
            const REWARD_AMOUNT = 3000;
            const WITHDRAWAL_MINIMUM_BIT = 1000000;
            const BIT_COIN_LOGO_URL = "https://images.pump.fun/coin-image/EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump?variant=600x600&ipfs=bafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre&src=https%3A%2F%2Fipfs.io%2Fipfs%2Fbafybeiekzpu4uxvcrbvzmzteiqmia3fe2ana2ttyueqgvxodlhcsbpibre";
            
             // --- CONFIGURACIÓN DEPÓSITO SOLANA (Automático) ---
            const DEPOSIT_DESTINATION_WALLET = '23V6CXerzmncibRPGXL2q5kJ4LhqhG1Mr2Q81WJw7U7Q'; // Tu wallet para recibir SOL
            const BIT_TOKEN_MINT = 'EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump'; // Address del token BIT para consulta de precio
            const SOL_DECIMALS = 9; // Decimales de SOL
            const TATUM_API_KEY = 't-68f69f0447bf5156a36067b3-b0b00e1660324a54ad70ef28'; // Tu API Key de Tatum (opcional pero recomendado)
            const RPC_URL = `https://solana-mainnet.gateway.tatum.io/`; // URL del RPC de Solana (Tatum o el que prefieras)

            let app, auth, db;
            let currentUser = null;
            let unsubscribeUser = null;
            let currentLang = 'en';
            let currentPageRender = () => renderExplorePage();
            let navigationHistory = [];
            let withdrawalUpdateInterval = null;
            let solanaConnection = null; // Variable para la conexión Solana

            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            
            // --- Mover selectores de DOM aquí ---
            const loginModal = document.getElementById('login-modal');
            const appContainer = document.getElementById('app-container');
            const loginForm = document.getElementById('login-form');
            const walletAddressInput = document.getElementById('wallet-address');
            const loginError = document.getElementById('login-error');
            const mainContent = document.getElementById('main-content');
            const userProfileArea = document.getElementById('user-profile-area');
            const loader = document.getElementById('loader');
            const recommendedChannelsContainer = document.getElementById('recommended-channels');
            const sidebar = document.getElementById('sidebar');
            const sidebarBackdrop = document.getElementById('sidebar-backdrop');
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenuIcon = document.getElementById('mobile-menu-icon');
            const backButton = document.getElementById('back-button');

             const translations = { // Definir translations antes de usarlo
                 en: {
                     explore: "Explore", categories: "Categories", creator: "Creator", creator_studio: "Creator Studio", recommended_channels: "Recommended Channels", followers: "followers", save: "Save", logout: "Log Out", processing: "Processing...", action_error: "Error processing action.", ad_warning: "An ad will appear in %s...", ad_playing: "Ad is playing...", welcome_to: "Welcome to", login_prompt: "Enter with your public Solana wallet address to start.", login_button: "Enter / Create Account", explore_title: "Explore Live Channels", categories_title: "Explore Categories", no_one_live: "No one is live in the '%s' category right now.", loading: "Loading", connecting_stream: "Connecting to stream...", live_chat: "Live Chat", chat_placeholder: "Send a message...", follow: "Follow", unfollow: "Unfollow", subscribe: "Subscribe", subscribed: "Subscribed", stream_ended: "The stream has ended.", sent: "sent", settings: "Settings", language: "Language", edit_profile: "Edit Profile", balance_withdrawal: "Balance & Withdrawal", current_balance: "Your Current Balance", withdrawal_minimum_bit: "You need a minimum of %a BIT to withdraw.", request_withdrawal: "Request Withdrawal", need_more_to_withdraw: "You need %a more BIT to withdraw.", withdrawal_ready: "You can request your withdrawal now.", withdrawal_requested: "Withdrawal request sent!", withdrawal_requested_toast: "Your withdrawal request has been sent.", withdrawal_error: "Error sending request.", profile_updated: "Profile updated successfully.", username: "Username", profile_pic_url: "Profile Picture URL", save_changes: "Save Changes", price_fetch_error: "Could not fetch price.", cannot_calculate_withdrawal: "Cannot calculate withdrawal requirements.", stream_dashboard: "Stream Dashboard", stream_title: "Stream Title", category: "Category", thumbnail_url: "Thumbnail URL (Optional)", thumbnail_placeholder: "https://example.com/image.png", microphone: "Microphone", use_camera: "Use Camera", share_screen: "Share Screen", preview: "Preview", chat: "Chat", start_stream: "Start", stop_stream: "Stop", analytics_rewards: "Analytics & Rewards", earnings_summary: "Earnings Summary", accumulated_rewards: "Accumulated Rewards", rewards_info: "You earn %a BIT for every %m minutes of streaming.", send_to_balance: "Send to Main Balance", followed_user: "You are now following %s.", unfollowed_user: "You have unfollowed %s.", insufficient_bits_subscribe: "You don't have enough BITs to subscribe.", subscribed_to_user: "You have subscribed to %s for 100 BIT", subscription_error: "Error processing subscription.", superchat_no_text: "Write a message to send with your VIP emoji.", insufficient_bits_emoji: "You need %p BIT to send this emoji.", superchat_error: "Error sending Super Chat.", media_error: "Could not access camera/screen.", no_video_source: "First select a video source.", stream_started: "Stream started!", stream_start_error: "Permission error. Could not start stream.", stream_stopped: "Stream stopped.", reward_notification: "+%a BIT for streaming %m minutes!", rewards_transferred: "%a BIT transferred to your balance.",
                 },
                 es: {
                     explore: "Explorar", categories: "Categorías", creator: "Creador", creator_studio: "Estudio del Creador", recommended_channels: "Canales Recomendados", followers: "seguidores", save: "Guardar", logout: "Cerrar Sesión", processing: "Procesando...", action_error: "Error al procesar la acción.", ad_warning: "Un anuncio aparecerá en %s...", ad_playing: "Anuncio en curso...", welcome_to: "Bienvenido a", login_prompt: "Ingresa con tu dirección de wallet pública de Solana para empezar.", login_button: "Entrar / Crear Cuenta", explore_title: "Explorar Canales en Vivo", categories_title: "Explorar Categorías", no_one_live: "No hay nadie en vivo en la categoría '%s' en este momento.", loading: "Cargando", connecting_stream: "Conectando al stream...", live_chat: "Chat en Vivo", chat_placeholder: "Escribe un mensaje...", follow: "Seguir", unfollow: "Dejar de Seguir", subscribe: "Suscribirse", subscribed: "Suscrito", stream_ended: "La transmisión ha finalizado.", sent: "envió", settings: "Configuración", language: "Idioma", edit_profile: "Editar Perfil", balance_withdrawal: "Balance y Retiros", current_balance: "Tu Saldo Actual", withdrawal_minimum_bit: "Necesitas un mínimo de %a BIT para retirar.", request_withdrawal: "Solicitar Retiro", need_more_to_withdraw: "Te faltan %a BIT para poder retirar.", withdrawal_ready: "Ya puedes solicitar tu retiro.", withdrawal_requested: "¡Solicitud de retiro enviada!", withdrawal_requested_toast: "Tu solicitud de retiro ha sido enviada.", withdrawal_error: "Error al enviar la solicitud.", profile_updated: "Perfil actualizado correctamente.", username: "Nombre de usuario", profile_pic_url: "URL de foto de perfil", save_changes: "Guardar Cambios", price_fetch_error: "No se pudo obtener el precio.", cannot_calculate_withdrawal: "No se pueden calcular los requisitos de retiro.", stream_dashboard: "Panel de Transmisión", stream_title: "Título del Stream", category: "Categoría", thumbnail_url: "URL de la Miniatura (Opcional)", thumbnail_placeholder: "https://ejemplo.com/imagen.png", microphone: "Micrófono", use_camera: "Usar Cámara", share_screen: "Compartir Pantalla", preview: "Vista Previa", chat: "Chat", start_stream: "Iniciar", stop_stream: "Detener", analytics_rewards: "Analíticas y Recompensas", earnings_summary: "Resumen de Ganancias", accumulated_rewards: "Recompensas Acumuladas", rewards_info: "Ganas %a BIT por cada %m minutos de transmisión.", send_to_balance: "Enviar a Balance Principal", followed_user: "Ahora sigues a %s.", unfollowed_user: "Has dejado de seguir a %s.", insufficient_bits_subscribe: "No tienes suficientes BITs para suscribirte.", subscribed_to_user: "Te has suscrito a %s por 100 BIT", subscription_error: "Error al procesar la suscripción.", superchat_no_text: "Escribe un mensaje para enviarlo con tu emoji VIP.", insufficient_bits_emoji: "Necesitas %p BIT para enviar este emoji.", superchat_error: "Error al enviar el Super Chat.", media_error: "No se pudo acceder a la cámara/pantalla.", no_video_source: "Primero selecciona una fuente de video.", stream_started: "¡Has iniciado la transmisión!", stream_start_error: "Error de permisos. No se pudo iniciar el stream.", stream_stopped: "Transmisión detenida.", reward_notification: "¡+%a BIT por transmitir %m minutos!", rewards_transferred: "%a BIT transferidos a tu balance.",
                 }
             };

             function setLanguage(lang) { // Mover setLanguage antes de su primer uso
                 currentLang = lang;
                 localStorage.setItem('lang', lang);
                 document.documentElement.lang = lang;
                 document.querySelectorAll('[data-key]').forEach(el => {
                     const key = el.dataset.key; if(translations[lang]?.[key]) el.textContent = translations[lang][key]; // Añadir check de existencia
                 });
                  document.querySelectorAll('[data-key-placeholder]').forEach(el => {
                     const key = el.dataset.keyPlaceholder; if(translations[lang]?.[key]) el.placeholder = translations[lang][key]; // Añadir check de existencia
                 });
             }

            // --- Mover funciones y lógica aquí ---
            
            // Helper function for delays
            // const delay = ms => new Promise(resolve => setTimeout(resolve, ms)); // Ya definido arriba

            // Helper function to check if libraries are loaded
            // const checkSolanaLibs = async (source) => { ... } // Ya definido arriba

            function requireAuth() {
                if (!currentUser) {
                    loginModal.style.display = 'flex';
                    setTimeout(() => document.querySelector('#login-modal > div').classList.remove('scale-95'), 10);
                    return false;
                }
                return true;
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    const storedWallet = localStorage.getItem('walletAddress');
                    if (storedWallet) {
                        await setupUser(storedWallet);
                    } else {
                        currentUser = null;
                        updateUIForAuthState();
                        loader.classList.add('hidden');
                    }
                } else {
                    currentUser = null;
                    currentLang = localStorage.getItem('lang') || 'en';
                    setLanguage(currentLang); // <- Llamada a setLanguage
                    updateUIForAuthState();
                    renderExplorePage(); // Asegurarse de renderizar explore si no hay usuario
                    appContainer.classList.remove('opacity-0');
                    loader.classList.add('hidden');
                }
            });

            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                loginError.textContent = '';
                const walletAddress = walletAddressInput.value.trim();
                 // Validar dirección de Solana (expresión regular básica)
                 const solanaAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
                 if (!solanaAddressRegex.test(walletAddress)) {
                     loginError.textContent = 'Please enter a valid Solana wallet address.';
                     return;
                 }
                loader.classList.remove('hidden');
                try {
                    localStorage.setItem('walletAddress', walletAddress);
                    if (!auth.currentUser) {
                        await signInAnonymously(auth);
                        // Esperar un poco para que onAuthStateChanged se dispare y llame a setupUser
                        await delay(500); 
                         if (!currentUser) { // Si setupUser no se llamó, forzarlo
                             await setupUser(walletAddress);
                         }
                    } else {
                        await setupUser(walletAddress);
                    }
                } catch (error) {
                    console.error("Login error:", error);
                    loginError.textContent = 'There was an error logging in. Please try again.';
                    localStorage.removeItem('walletAddress');
                    loader.classList.add('hidden');
                }
            });
            
            async function setupUser(wallet) {
                const userRef = doc(db, "users", wallet);
                const userSnap = await getDoc(userRef);
                 let userData = null;
                if (!userSnap.exists()) {
                     userData = {
                        walletAddress: wallet, username: `Wallet...${wallet.substring(wallet.length - 4)}`, profilePicture: `https://placehold.co/128x128/1a1a1a/4ade80?text=${wallet.substring(0,1)}`, bitBalance: 1000, creatorRewardsBalance: 0, createdAt: serverTimestamp(), authUid: auth.currentUser?.uid || null, followersCount: 0, followingCount: 0
                    };
                    await setDoc(userRef, userData);
                } else {
                     userData = userSnap.data();
                    const updates = {};
                    if (!userData.username) updates.username = `Wallet...${wallet.substring(wallet.length - 4)}`;
                    if (auth.currentUser && userData.authUid !== auth.currentUser.uid) updates.authUid = auth.currentUser.uid;
                     if (Object.keys(updates).length > 0) {
                         await updateDoc(userRef, updates);
                         userData = { ...userData, ...updates }; // Actualizar datos locales
                     }
                }
                // Asegurarse de que currentUser se establezca aquí, no solo en onSnapshot
                currentUser = { ...userData, walletAddress: wallet }; 
                loadUserProfile(wallet); // Iniciar escucha de cambios
            }

            async function loadUserProfile(wallet) {
                if (unsubscribeUser) unsubscribeUser();
                const userRef = doc(db, "users", wallet);
                let isInitialLoad = true;
                unsubscribeUser = onSnapshot(userRef, (docSnap) => {
                    if (docSnap.exists()) {
                        currentUser = { ...docSnap.data(), walletAddress: docSnap.id };
                        if (isInitialLoad) {
                            currentLang = localStorage.getItem('lang') || 'en';
                            setLanguage(currentLang); // <- Llamada a setLanguage
                            updateUIForAuthState();
                            loginModal.style.display = 'none';
                            appContainer.classList.remove('opacity-0');
                            loader.classList.add('hidden');
                            isInitialLoad = false;
                            // Renderizar la página actual solo si no es la página de login
                            if (currentPageRender !== requireAuth) {
                                currentPageRender(); 
                            } else {
                                renderExplorePage(); // Ir a explore por defecto al loguearse
                            }
                        }
                        renderHeader();
                    } else { 
                        // Si el documento ya no existe, desloguear
                         console.warn("User document not found for:", wallet);
                         logout(); 
                    }
                }, (error) => { 
                    console.error("Error listening to user changes:", error); 
                    // Considerar desloguear aquí también si hay error persistente
                    // logout(); 
                });
            }

            function updateUIForAuthState() {
                renderHeader();
                const creatorSection = document.getElementById('creator-section');
                if (creatorSection) creatorSection.style.display = currentUser ? 'block' : 'none';
                if (currentUser) {
                    loadRecommendedChannels();
                } else if (recommendedChannelsContainer) { // Ensure container exists
                    recommendedChannelsContainer.innerHTML = '';
                }
                 // Configurar navegación solo una vez (movido al final del DOMContentLoaded)
                // if (!navigationHistory.length && document.body.dataset.navSetup !== 'true') { 
                //      setupNavigation();
                //      document.body.dataset.navSetup = 'true'; // Marcar que ya se configuró
                // }
            }
            
            function logout() {
                stopStream();
                if (withdrawalUpdateInterval) clearInterval(withdrawalUpdateInterval);
                if(unsubscribeUser) unsubscribeUser();
                unsubscribeUser = null; // Resetear listener
                currentUser = null; // Asegurar que currentUser es null
                localStorage.removeItem('walletAddress');
                if(auth.currentUser) {
                     auth.signOut().catch(error => console.error("Error signing out:", error));
                     // onAuthStateChanged se encargará del resto
                } else {
                     // Si ya estaba deslogueado, solo actualizar UI
                     updateUIForAuthState();
                     renderExplorePage();
                }
            }

            function renderHeader() {
                if (!userProfileArea) return; 

                if (currentUser) {
                    userProfileArea.innerHTML = `
                        <div class="flex items-center gap-1 md:gap-2 bg-[var(--background-tertiary)] px-2 md:px-3 py-1.5 rounded-full">
                            <img src="${BIT_COIN_LOGO_URL}" class="w-5 h-5 rounded-full object-cover">
                            <span class="font-semibold text-white text-sm md:text-base">${(currentUser.bitBalance || 0).toLocaleString()} <span class="hidden sm:inline">BIT</span></span>
                        </div>
                        <button id="profile-button" class="group flex items-center gap-2">
                            <img src="${currentUser.profilePicture || 'https://placehold.co/40x40/1a1a1a/eaeaea?text=?'}" alt="Profile Picture" class="w-9 h-9 md:w-10 md:h-10 rounded-full object-cover border-2 border-[var(--border-color)] group-hover:border-[var(--brand-color-purple)] transition-colors">
                            <span class="hidden md:block font-semibold group-hover:text-[var(--brand-color-purple)]">${currentUser.username || 'User'}</span>
                        </button>`;
                         // Añadir listener al botón de perfil si no existe ya
                         const profileButton = document.getElementById('profile-button');
                         if (profileButton && !profileButton.dataset.listenerAttached) {
                            profileButton.addEventListener('click', () => {
                                if (!requireAuth()) return;
                                navigationHistory.push(currentPageRender);
                                cleanupWatchPage();
                                renderSettingsPage();
                            });
                             profileButton.dataset.listenerAttached = 'true';
                         }
                } else {
                    userProfileArea.innerHTML = `
                        <button id="login-button-header" class="purple-gradient-bg text-white font-bold py-2 px-4 rounded-lg transition-all duration-300 transform hover:scale-105">
                            Log In
                        </button>`;
                    const loginButton = document.getElementById('login-button-header');
                    if (loginButton && !loginButton.dataset.listenerAttached) { 
                        loginButton.addEventListener('click', () => {
                             loginModal.style.display = 'flex';
                        });
                         loginButton.dataset.listenerAttached = 'true';
                    }
                }
                lucide.createIcons();
            }
            
            async function loadRecommendedChannels() {
                if(!currentUser || !recommendedChannelsContainer) return; // Ensure container exists
                recommendedChannelsContainer.innerHTML = `<div class="p-2 text-center text-xs text-[var(--text-secondary)]">Loading channels...</div>`; // Placeholder
                try {
                    const usersQuery = query(collection(db, "users"), where("walletAddress", "!=", currentUser.walletAddress), limit(5));
                    const usersSnapshot = await getDocs(usersQuery);
                    recommendedChannelsContainer.innerHTML = ''; // Clear placeholder/existing content
                    if (usersSnapshot.empty) {
                        recommendedChannelsContainer.innerHTML = `<div class="p-2 text-center text-xs text-[var(--text-secondary)]">No channels found.</div>`;
                        return;
                    }
                    usersSnapshot.forEach(doc => {
                        const user = doc.data();
                        const channelEl = document.createElement('div');
                        channelEl.className = 'flex items-center gap-3 p-1 rounded-lg hover:bg-[var(--background-tertiary)] cursor-pointer';
                        channelEl.innerHTML = `
                            <img src="${user.profilePicture || 'https://placehold.co/32x32/1a1a1a/eaeaea?text=?'}" class="w-8 h-8 rounded-full">
                            <div class="flex-1 overflow-hidden">
                                <p class="text-sm font-semibold truncate">${user.username || user.walletAddress.substring(0,6)}</p>
                                <p class="text-xs text-[var(--text-secondary)]">${user.followersCount || 0} ${translations[currentLang].followers}</p>
                            </div>`;
                         // TODO: Add click listener to navigate to user profile/stream if implemented
                        recommendedChannelsContainer.appendChild(channelEl);
                    });
                } catch (error) {
                    console.error("Error loading recommended channels:", error);
                    recommendedChannelsContainer.innerHTML = `<div class="p-2 text-center text-xs text-red-500">Error loading channels.</div>`;
                }
            }

            function showToast(message, type = 'success') {
                 const toast = document.getElementById('toast');
                 const toastMessage = document.getElementById('toast-message');
                 if (!toast || !toastMessage) return;

                 toast.classList.remove('bg-green-600', 'bg-red-600', 'bg-blue-600'); 
                 if (type === 'error') toast.classList.add('bg-red-600');
                 else if (type === 'info') toast.classList.add('bg-blue-600');
                 else toast.classList.add('bg-green-600'); 

                 toastMessage.textContent = message;
                 toast.classList.remove('translate-y-20', 'opacity-0');
                 setTimeout(() => {
                     toast.classList.add('translate-y-20', 'opacity-0');
                 }, 4000);
            }

             // Helper to copy text to clipboard (ya no se usa en depósito)
             function copyToClipboard(text, elementToHighlight = null) {
                 // ... (código existente) ...
             }

             // --- NAVIGATION & UI HELPERS --- (Mover renderPage y setupNavigation aquí)

             function renderPage(content, activeTargetKey, isSubPage = false) {
                  if (!mainContent) return; 
                 mainContent.innerHTML = `<div class="animate-slide-in">${content}</div>`;
                 setActiveLink(activeTargetKey);
                 updateHeaderButtons(isSubPage);
                 setLanguage(currentLang); // <- Llamada a setLanguage
                 lucide.createIcons();
             }

             function setupNavigation() { // Definir antes de usarla
                 const pages = {
                     'explore': { render: renderExplorePage, pageKey: 'explore', auth: false },
                     'categories': { render: renderCategoriesPage, pageKey: 'categories', auth: false },
                     'studio': { render: renderStudioPage, pageKey: 'studio', auth: true }
                 };

                 document.body.addEventListener('click', (e) => {
                     // Listener para el botón de perfil ya está en renderHeader

                     const navAction = e.target.closest('.nav-action');
                     if (navAction && navAction.dataset.target) { // Verificar que sea un link de navegación principal
                         e.preventDefault();
                         const targetPageKey = navAction.dataset.target;
                         const page = pages[targetPageKey];
                         if (page) {
                             if(page.auth && !requireAuth()) return;
                             if (navigationHistory[navigationHistory.length - 1] !== currentPageRender) {
                                 navigationHistory.push(currentPageRender);
                             }
                             cleanupWatchPage();
                             currentPageRender = page.render;
                             currentPageRender();
                         }
                     }
                 });
                
                 if (backButton) { 
                     backButton.addEventListener('click', () => {
                         if (navigationHistory.length > 0) {
                             cleanupWatchPage();
                             const previousPage = navigationHistory.pop();
                             if (typeof previousPage === 'function') {
                                 currentPageRender = previousPage;
                                 previousPage();
                             } else {
                                 // Fallback si el historial está corrupto
                                 renderExplorePage(); 
                             }
                         } else {
                              renderExplorePage(); // Si no hay historial, ir a explore
                         }
                     });
                 }

                 function toggleSidebar() {
                     if (!sidebar || !sidebarBackdrop || !mobileMenuIcon) return; 
                     sidebar.classList.toggle('-translate-x-full');
                     sidebarBackdrop.classList.toggle('hidden');
                     mobileMenuIcon.setAttribute('data-lucide', sidebar.classList.contains('-translate-x-full') ? 'menu' : 'x');
                     lucide.createIcons();
                 }

                if(mobileMenuBtn) mobileMenuBtn.addEventListener('click', toggleSidebar); 
                if(sidebarBackdrop) sidebarBackdrop.addEventListener('click', toggleSidebar); 
                if(sidebar) { 
                     sidebar.addEventListener('click', (e) => {
                         // Cerrar sidebar al hacer clic en un link de navegación dentro de ella
                         if (e.target.closest('a.nav-action[data-target]')) {
                             // Pequeño delay para que la navegación ocurra antes de cerrar
                             setTimeout(toggleSidebar, 100); 
                         }
                     });
                }
                  document.body.dataset.navSetup = 'true'; // Marcar que la navegación está configurada
             }
            
             function updateHeaderButtons(isSubPage) {
                if(backButton) backButton.classList.toggle('hidden', !isSubPage); 
                if(mobileMenuBtn) mobileMenuBtn.classList.toggle('hidden', isSubPage); 
             }

             function setActiveLink(activeTargetKey) {
                  document.querySelectorAll('.nav-link[data-target]').forEach(link => {
                     link.classList.toggle('active', link.dataset.target === activeTargetKey);
                 });
             }


            // --- RENDER FUNCTIONS ---

            async function renderExplorePage() {
                currentPageRender = renderExplorePage;
                 mainContent.innerHTML = `<div class="p-8 text-center text-[var(--text-secondary)]">${translations[currentLang].loading}...</div>`; // Placeholder inicial
                let streamsQuery = query(collection(db, "streams"), where("status", "==", "live"));
                
                let streamsHTML = '';
                try {
                    const querySnapshot = await getDocs(streamsQuery);
                    if (querySnapshot.empty) {
                        streamsHTML = `<p class="text-center text-[var(--text-secondary)] col-span-full">${translations[currentLang].no_one_live.replace('%s', 'any')}</p>`;
                    } else {
                        querySnapshot.forEach(doc => {
                            const stream = doc.data();
                            streamsHTML += `
                                <div class="stream-card group bg-[var(--background-secondary)] rounded-xl overflow-hidden border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] transition-all transform hover:-translate-y-1 duration-300 cursor-pointer" data-streamer-wallet="${doc.id}">
                                    <div class="relative"><img src="${stream.thumbnailUrl || 'https://placehold.co/400x225/141418/2a2a32?text=En+Vivo'}" class="w-full h-40 object-cover" onerror="this.src='https://placehold.co/400x225/141418/2a2a32?text=Error'">
                                        <div class="absolute top-2 left-2 bg-red-600 text-white text-xs font-bold px-2 py-1 rounded-md">LIVE</div>
                                        <div class="absolute bottom-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded-md flex items-center gap-1"><i data-lucide="users" class="w-3 h-3"></i> ${stream.viewerCount || 0}</div>
                                    </div>
                                    <div class="p-4 flex items-start gap-3"><img src="${stream.streamerPic || 'https://placehold.co/40x40/1a1a1a/eaeaea?text=?'}" class="w-10 h-10 rounded-full" onerror="this.src='https://placehold.co/40x40/1a1a1a/eaeaea?text=?';">
                                        <div><h3 class="font-bold text-md truncate">${stream.title || 'Untitled Stream'}</h3>
                                            <p class="text-sm text-[var(--text-secondary)]">${stream.streamerUsername || stream.streamerWallet.substring(0, 6)}</h6>
                                            <span class="text-xs bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded-full">${stream.category || 'General'}</span>
                                        </div>
                                    </div>
                                </div>`;
                        });
                    }
                } catch (error) {
                    console.error("Error fetching streams:", error);
                    streamsHTML = `<p class="text-center text-red-500 col-span-full">Error loading streams.</p>`;
                }
                
                renderPage(`<h1 class="text-3xl font-bold mb-6" data-key="explore_title">${translations[currentLang].explore_title}</h1>
                    <div id="streams-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">${streamsHTML}</div>`, 'explore');
                
                document.querySelectorAll('.stream-card').forEach(card => {
                    card.addEventListener('click', () => {
                        if (navigationHistory[navigationHistory.length - 1] !== currentPageRender) {
                             navigationHistory.push(currentPageRender);
                        }
                        const streamerWallet = card.dataset.streamerWallet;
                        renderWatchStreamPage(streamerWallet);
                    });
                });
            }
            
            function renderCategoriesPage() {
                currentPageRender = renderCategoriesPage;
                const categoriesHTML = CATEGORIES.map(cat => `
                    <div class="category-card group bg-[var(--background-secondary)] rounded-xl overflow-hidden border border-[var(--border-color)] hover:border-[var(--brand-color-purple)] transition-all transform hover:-translate-y-1 duration-300 cursor-pointer" data-category="${cat}">
                        <img src="${CATEGORY_IMAGES[cat] || `https://placehold.co/300x400/141418/2a2a32?text=${cat.replace(' ', '+')}`}" class="w-full h-auto object-cover" onerror="this.src='https://placehold.co/300x400/141418/2a2a32?text=Error'">
                        <div class="p-4 bg-[var(--background-secondary)]"><h3 class="font-bold text-lg truncate">${cat}</h3></div>
                    </div>`).join('');
                
                renderPage(`<h1 class="text-3xl font-bold mb-6" data-key="categories_title">Explore Categories</h1>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6">${categoriesHTML}</div>`, 'categories');

                document.querySelectorAll('.category-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const category = card.dataset.category;
                        mainContent.innerHTML = `<div class="text-center p-8">${translations[currentLang].loading}...</div>`; 
                        // TODO: Implement actual category filtering in renderExplorePage if needed
                        renderExplorePage(/* category */); 
                    });
                });
            }
            
            function renderSettingsPage() {
                 currentPageRender = renderSettingsPage;
                 if (!currentUser) {
                     // Si no hay usuario, redirigir a explore o mostrar mensaje
                     renderExplorePage();
                     showToast("Please log in to access settings.", "info");
                     return;
                 }; 
                 const profileHTML = `
                 <div class="space-y-4">
                    <div><img src="https://placehold.co/1200x300/1f1f1f/1f1f1f" class="w-full h-40 object-cover rounded-2xl"></div>
                    <div class="flex flex-col items-center -mt-20"><img src="${currentUser.profilePicture || 'https://placehold.co/128x128/1a1a1a/eaeaea?text=?'}" class="w-32 h-32 rounded-full object-cover border-4 border-[var(--background-primary)]" onerror="this.src='https://placehold.co/128x128/1a1a1a/eaeaea?text=?';">
                        <div class="text-center mt-2"><h1 class="text-2xl font-bold">${currentUser.username || 'User'}</h1><p class="text-sm text-[var(--text-secondary)] break-all px-2">${currentUser.walletAddress}</p></div>
                    </div>
                    <div class="pt-4 grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div class="lg:col-span-1 space-y-6">
                            <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]"><h3 class="font-semibold text-lg mb-4" data-key="settings">Settings</h3>
                                <label for="lang-select" class="font-semibold text-sm" data-key="language">Language</label>
                                <select id="lang-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2">
                                    <option value="en" ${currentLang === 'en' ? 'selected' : ''}>English</option><option value="es" ${currentLang === 'es' ? 'selected' : ''}>Español</option>
                                </select>
                            </div>
                            <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]"><h3 class="font-semibold text-lg mb-4" data-key="edit_profile">Edit Profile</h3>
                                <div class="space-y-3">
                                    <div><label for="username-input" class="text-sm font-medium text-[var(--text-secondary)]" data-key="username">Username</label><input type="text" id="username-input" value="${currentUser.username || ''}" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-purple)]"></div>
                                    <div><label for="profile-pic-url" class="text-sm font-medium text-[var(--text-secondary)]" data-key="profile_pic_url">Profile Picture URL</label><input type="text" id="profile-pic-url" value="${currentUser.profilePicture || ''}" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-purple)]"></div>
                                </div>
                                <button id="save-profile" class="mt-4 w-full purple-gradient-bg text-white font-semibold py-2 rounded-lg transition-all hover:scale-105" data-key="save">Save Changes</button>
                                <button id="logout-button" class="mt-3 w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded-lg transition-all" data-key="logout">Log Out</button>
                            </div>
                        </div>
                        <div class="lg:col-span-2 space-y-6">
                             <!-- INICIO: Sección Depósito Automático SOL -->
                            <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]">
                                 <h3 class="font-semibold text-lg mb-4">Depositar SOL (para obtener BIT)</h3>
                                <div id="solana-deposit-container">
                                    <div id="deposit-form-section">
                                        <label for="deposit-amount-sol" class="block text-sm font-medium text-[var(--text-secondary)] mb-2">Monto en SOL a Depositar</label>
                                        <div class="relative">
                                            <input type="number" id="deposit-amount-sol" class="w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-[var(--brand-color-purple)]" placeholder="Ej: 0.5">
                                            <span class="absolute inset-y-0 right-0 pr-3 flex items-center text-sm text-gray-400">SOL</span>
                                        </div>
                                         <p id="bit-estimate" class="text-xs text-center text-purple-300 h-4 mt-1"></p> 
                                        <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
                                            <button id="generate-qr-btn-sol" class="w-full purple-gradient-bg text-white font-bold py-3 rounded-lg transition-all hover:opacity-90 flex items-center justify-center gap-2">
                                                <i data-lucide="qr-code"></i> Pagar con QR (SOL)
                                            </button>
                                            <button id="pay-with-phantom-btn-sol" class="w-full bg-purple-800 text-white font-bold py-3 rounded-lg transition-all hover:bg-purple-700 flex items-center justify-center gap-2">
                                                <img src="https://phantom.app/img/logo.png" class="w-5 h-5"> Pagar con Phantom (SOL)
                                            </button>
                                        </div>
                                    </div>
                                    <div id="deposit-status-section-sol" class="text-center hidden">
                                         <h4 id="deposit-title-sol" class="text-md font-semibold mb-3">Escanea para Pagar SOL</h4>
                                         <div id="deposit-qr-code-sol" class="flex justify-center items-center my-4"></div>
                                         <div class="flex items-center justify-center space-x-2">
                                            <div id="deposit-spinner-sol" class="spinner-deposit h-5 w-5 rounded-full border-2 border-gray-600 border-t-purple-500"></div>
                                            <p id="deposit-status-message-sol" class="text-[var(--text-secondary)] text-sm">Esperando pago de SOL...</p>
                                         </div>
                                         <button id="deposit-cancel-btn-sol" class="mt-4 w-full bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 rounded-lg transition-all">Cancelar</button>
                                    </div>
                                    <p class="text-xs text-center text-gray-500 mt-3">Los depósitos se acreditan automáticamente en BIT una vez confirmada la transacción de SOL.</p>
                                </div>
                            </div>
                             <!-- FIN: Sección Depósito Automático SOL -->

                            <div class="bg-[var(--background-secondary)] p-6 rounded-2xl border border-[var(--border-color)]">
                                <h3 class="font-semibold text-lg mb-4" data-key="balance_withdrawal">Balance & Withdrawal</h3>
                                <div class="bg-[var(--background-tertiary)] p-6 rounded-lg mb-6">
                                    <p class="text-sm text-[var(--text-secondary)]" data-key="current_balance">Your Current Balance</p>
                                    <div class="flex items-center gap-2"><img src="${BIT_COIN_LOGO_URL}" class="w-10 h-10 rounded-full object-cover"><p class="text-4xl font-bold text-white">${(currentUser.bitBalance || 0).toLocaleString()} <span class="text-2xl font-normal text-purple-300">BIT</span></p></div>
                                    <p class="text-lg text-green-400 h-7 mt-2" id="usd-equivalent-display">...</p>
                                </div>
                                <p class="text-sm text-[var(--text-secondary)]" id="withdrawal-info-text" data-key="withdrawal_minimum_bit">You need a minimum of ${WITHDRAWAL_MINIMUM_BIT.toLocaleString()} BIT to withdraw.</p>
                                <div id="token-price-info" class="text-xs text-gray-500 h-4 mt-1"></div>
                                <button id="withdraw-button" class="mt-4 w-full purple-gradient-bg text-white font-bold py-3 rounded-lg transition-all disabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled data-key="request_withdrawal">Request Withdrawal</button>
                                <div id="withdraw-message" class="text-center text-sm h-5 mt-2"></div>
                            </div>
                        </div>
                    </div>
                </div>`;
                renderPage(profileHTML, null, true); 
                document.getElementById('save-profile')?.addEventListener('click', saveProfile); 
                document.getElementById('logout-button')?.addEventListener('click', logout); 
                document.getElementById('withdraw-button')?.addEventListener('click', requestWithdrawal); 
                document.getElementById('lang-select')?.addEventListener('change', (e) => setLanguage(e.target.value));
                
                // Actualizar info de retiro y precio SOL/BIT al cargar la página
                if (!withdrawalUpdateInterval) { // Iniciar si no está corriendo
                     updateWithdrawalStatus(); // Llamada inicial
                     withdrawalUpdateInterval = setInterval(updateWithdrawalStatus, 60000); // Chequear cada minuto
                } else {
                     updateWithdrawalStatus(); // Forzar actualización si ya corre
                }

                setupSolanaDeposit(); // <-- Inicializa la nueva lógica de depósito SOL
            }
            
            // ... (Resto de las funciones renderStudioPage, renderWatchStreamPage, etc.) ...
            function renderStudioPage() { // Asegurarse de que esta y otras funciones de renderizado existan
                 currentPageRender = renderStudioPage;
                 const studioHTML = `
                     <div class="bg-[var(--background-secondary)] rounded-2xl border border-[var(--border-color)] min-h-[70vh] flex flex-col md:flex-row">
                         <div class="w-full md:w-1/3 lg:w-1/4 border-b md:border-b-0 md:border-r border-[var(--border-color)] p-4 space-y-2">
                             <h2 class="text-xl font-bold p-2" data-key="creator_studio">Creator Studio</h2>
                             <button class="studio-tab-btn w-full text-left flex items-center gap-3 px-3 py-2.5 rounded-lg" data-target="studio-stream"><i data-lucide="video"></i><span data-key="stream">Stream</span></button>
                             <button class="studio-tab-btn w-full text-left flex items-center gap-3 px-3 py-2.5 rounded-lg" data-target="studio-analytics"><i data-lucide="bar-chart-2"></i><span data-key="analytics_rewards">Analytics & Rewards</span></button>
                         </div><div id="studio-content" class="w-full md:w-2/3 lg:w-3/4 p-4 md:p-8"></div>
                     </div>`;
                 renderPage(studioHTML, 'studio', true);
                 const tabButtons = document.querySelectorAll('.studio-tab-btn');
                 const studioContent = document.getElementById('studio-content');
                 const tabs = { 'studio-stream': renderStudioStream, 'studio-analytics': renderStudioAnalytics };
                 function switchTab(targetId) {
                     tabButtons.forEach(btn => btn.classList.toggle('bg-[var(--background-tertiary)]', btn.dataset.target === targetId));
                     if (studioContent) { // Check if element exists
                         studioContent.innerHTML = `<div class="animate-fade-in">${tabs[targetId]()}</div>`;
                         setLanguage(currentLang);
                         lucide.createIcons();
                         if(targetId === 'studio-analytics') attachAnalyticsListeners();
                         if(targetId === 'studio-stream') attachStreamListeners();
                     }
                 }
                 tabButtons.forEach(btn => btn.addEventListener('click', () => switchTab(btn.dataset.target)));
                 switchTab('studio-stream'); // Initial tab
             }
             
             function renderStudioStream() {
                 //currentPageRender = renderStudioStream; // No es necesario setear currentPageRender aquí
                 const categoriesOptions = CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join('');
                 return `
                     <div class="flex flex-col lg:flex-row gap-6 h-full">
                         <div class="w-full lg:w-2/3 space-y-4"><h2 class="text-2xl font-bold" data-key="stream_dashboard">Stream Dashboard</h2>
                             <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                  <div><label class="font-semibold text-sm" data-key="stream_title">Stream Title</label><input id="stream-title-input" type="text" value="My awesome stream on Live Payout!" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></div>
                                  <div><label class="font-semibold text-sm" data-key="category">Category</label><select id="stream-category-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2">${categoriesOptions}</select></div>
                             </div>
                              <div><label class="font-semibold text-sm" data-key="thumbnail_url">Thumbnail URL (Optional)</label><input id="stream-thumbnail-input" type="text" data-key-placeholder="thumbnail_placeholder" placeholder="https://example.com/image.png" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></div>
                             <div><label class="font-semibold text-sm" data-key="microphone">Microphone</label><select id="mic-select" class="mt-1 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2"></select></div>
                             <div class="flex flex-col sm:flex-row gap-4">
                                 <button id="select-cam-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white p-3 rounded-lg flex items-center justify-center gap-2 transition-colors disabled:opacity-50" data-key="use_camera"><i data-lucide="camera"></i>Use Camera</button>
                                 <button id="select-screen-btn" class="flex-1 purple-gradient-bg hover:opacity-90 text-white p-3 rounded-lg flex items-center justify-center gap-2 transition-colors disabled:opacity-50" data-key="share_screen"><i data-lucide="screen-share"></i>Share Screen</button>
                             </div>
                             <div class="bg-black p-2 rounded-lg">
                                 <h3 class="font-semibold text-center mb-2 flex items-center justify-center gap-2" id="stream-status-container">
                                     <span id="stream-status-text" data-key="preview">Preview</span><span id="studio-viewer-count" class="flex items-center gap-1 text-sm text-gray-400"></span><span id="stream-timer" class="font-mono"></span>
                                 </h3><video id="local-video-preview" muted autoplay playsinline></video>
                             </div>
                         </div>
                         <div class="w-full lg:w-1/3 flex flex-col gap-4">
                              <div class="flex items-center justify-between"><h2 class="text-2xl font-bold" data-key="chat">Chat</h2></div>
                             <div id="studio-chat-messages" class="flex-grow bg-[var(--background-tertiary)] rounded-lg p-2 space-y-2 overflow-y-auto border border-[var(--border-color)] h-64 lg:h-auto"></div>
                             <div class="flex gap-4">
                                 <button id="start-stream-btn" class="flex-1 purple-gradient-bg text-white font-bold p-3 rounded-lg flex items-center justify-center gap-2 disabled:opacity-50" disabled><i data-lucide="play-circle"></i><span data-key="start_stream">Start</span></button>
                                 <button id="stop-stream-btn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold p-3 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-600 disabled:opacity-50" disabled><i data-lucide="stop-circle"></i><span data-key="stop_stream">Stop</span></button>
                             </div>
                         </div>
                     </div>`;
             }
             
             function renderStudioAnalytics() {
                 //currentPageRender = renderStudioAnalytics; // No es necesario
                 if (!currentUser) return `<div class="text-center">${translations[currentLang].loading}...</div>`;
                 return `
                     <h2 class="text-2xl font-bold mb-6" data-key="analytics_rewards">Analytics & Rewards</h2>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                          <div class="bg-[var(--background-tertiary)] p-6 rounded-xl border border-[var(--border-color)] md:col-span-2">
                              <div class="flex items-center justify-between mb-4">
                                 <h3 class="font-semibold text-lg" data-key="earnings_summary">Earnings Summary</h3>
                                 <i data-lucide="award" class="w-6 h-6 text-purple-400"></i>
                             </div>
                             <div class="flex items-center gap-2 my-2">
                                 <img src="${BIT_COIN_LOGO_URL}" class="w-10 h-10 rounded-full object-cover">
                                 <p class="text-4xl font-bold">${(currentUser.creatorRewardsBalance || 0).toLocaleString()} <span class="text-purple-300">BIT</span></p>
                             </div>
                             <p class="text-xs text-[var(--text-secondary)] mt-4">${translations[currentLang].rewards_info.replace('%a', REWARD_AMOUNT.toLocaleString()).replace('%m', REWARD_INTERVAL_MINUTES)}</p>
                             <button id="transfer-rewards" class="w-full purple-gradient-bg hover:opacity-90 text-white font-bold py-3 rounded-lg transition-all mt-4 disabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" ${(currentUser.creatorRewardsBalance || 0) <= 0 ? 'disabled' : ''} data-key="send_to_balance">Send to Main Balance</button>
                         </div>
                     </div>
                     <div class="mt-6"><img src="https://placehold.co/800x400/1e1e24/2a2a32?text=Performance+Charts" class="w-full rounded-lg"></div>`;
             }
             
             let unsubscribeChat = null;
             let unsubscribeStream = null;
             let viewerPeerConnection = null;
             async function renderWatchStreamPage(streamerWallet) {
                 currentPageRender = () => renderWatchStreamPage(streamerWallet);
                  if (mainContent) {
                     mainContent.classList.add('!p-0', 'md:!p-0', '!overflow-hidden');
                     mainContent.classList.remove('p-4', 'md:p-8'); // Remover padding
                  }

                 let streamerData = { profilePicture: '', followersCount: 0, username: 'Streamer' };
                 try {
                     const streamerDoc = await getDoc(doc(db, "users", streamerWallet));
                     if (streamerDoc.exists()) {
                         streamerData = streamerDoc.data();
                     } else {
                          console.warn("Streamer data not found for:", streamerWallet);
                          // Quizás redirigir o mostrar un mensaje de error?
                          renderExplorePage(); // Volver a explore si el streamer no existe
                          showToast("Streamer not found.", "error");
                          return;
                     }
                 } catch (error) {
                     console.error("Error fetching streamer data:", error);
                     // Mostrar error y volver a explore
                     renderExplorePage();
                     showToast("Error loading stream data.", "error");
                     return;
                 }

                 const watchHTML = `
                 <div class="w-full h-full flex flex-col lg:flex-row">
                     <!-- Top section (scrollable): Video + info -->
                     <div class="flex-1 lg:p-8 p-4 overflow-y-auto">
                         <div class="flex flex-col gap-4 max-w-4xl mx-auto">
                              <div id="video-container" class="relative w-full aspect-video bg-black rounded-lg flex items-center justify-center flex-shrink-0">
                                 <div id="video-overlay" class="absolute inset-0 flex items-center justify-center text-white text-xl z-10" data-key="connecting_stream">Connecting to stream...</div>
                                 <video id="remote-video" autoplay playsinline class="w-full h-full object-contain opacity-0 transition-opacity duration-500"></video>
                             </div>
                             <div id="stream-info-panel">
                                 <div class="bg-[var(--background-secondary)] p-4 rounded-lg border border-[var(--border-color)] flex flex-col sm:flex-row justify-between items-center gap-4">
                                     <div class="flex items-center gap-4">
                                         <h2 id="stream-title-display" class="font-bold text-lg">Loading...</h2>
                                         <p class="text-sm text-[var(--text-secondary)]">${streamerData.username || 'Streamer'} | ${streamerData.followersCount || 0} <span data-key="followers">followers</span></p>
                                     </div>
                                 </div>
                                 <div class="flex items-center gap-2 mt-2">
                                     <button id="follow-btn" class="font-bold py-2 px-6 rounded-lg transition-all h-11 flex-1 bg-gray-800 text-center"></button>
                                     <button id="subscribe-btn" class="purple-gradient-bg hover:opacity-90 text-white font-bold py-2 px-6 rounded-lg flex items-center justify-center gap-2 h-11 flex-1">
                                         <i data-lucide="star" class="w-4 h-4"></i> <span data-key="subscribe">Subscribe</span> (100 BIT)
                                     </button>
                                 </div>
                             </div>
                         </div>
                     </div>

                     <!-- Bottom section (fixed height on mobile): Chat -->
                     <div class="w-full lg:w-80 lg:max-h-full flex-shrink-0 bg-[var(--background-secondary)] lg:rounded-lg p-4 flex flex-col border-t lg:border-l lg:border-t-0 border-[var(--border-color)] h-1/2 lg:h-auto">
                         <h3 class="font-bold text-lg mb-2 flex-shrink-0" data-key="live_chat">Live Chat</h3>
                         <div id="chat-messages" class="flex-grow space-y-2 overflow-y-auto pr-2 min-h-0"></div>
                         <div id="chat-input-container" class="flex-shrink-0 relative mt-auto pt-4" style="padding-bottom: env(safe-area-inset-bottom);">
                              <div id="vip-emoji-panel" class="hidden absolute bottom-full mb-2 left-0 w-full bg-[var(--background-tertiary)] border border-[var(--border-color)] rounded-lg p-2 grid grid-cols-5 gap-2">
                                ${VIP_EMOJIS.map(e => `<button class="vip-emoji-btn group" data-emoji-id="${e.id}"><img src="${e.url}" class="w-10 h-10 transition-transform group-hover:scale-110"><div class="text-xs flex items-center justify-center gap-1">${e.price} <img src="${BIT_COIN_LOGO_URL}" class="w-3 h-3 rounded-full object-cover inline-block"></div></button>`).join('')}
                             </div>
                             <form id="chat-form" class="flex gap-2">
                                <button type="button" id="open-vip-emojis" class="flex-shrink-0 p-2 purple-gradient-bg hover:opacity-90 rounded-lg"><i data-lucide="smile"></i></button>
                                <input type="text" id="chat-input" data-key-placeholder="chat_placeholder" placeholder="Send a message..." class="flex-grow bg-[var(--background-tertiary)] rounded-lg px-3 py-2 text-sm min-w-0" required>
                                <button type="submit" class="flex-shrink-0 purple-gradient-bg px-3 rounded-lg"><i data-lucide="send"></i></button>
                             </form>
                         </div>
                     </div>
                 </div>`;
                 if (mainContent) mainContent.innerHTML = watchHTML; // Check before setting innerHTML
                 setLanguage(currentLang);
                 lucide.createIcons();
                 updateHeaderButtons(true);
                
                 joinStream(streamerWallet);

                 const chatInputContainer = document.getElementById('chat-input-container');
                 const streamInfoPanel = document.getElementById('stream-info-panel');
                 if (!currentUser) {
                     if (chatInputContainer) {
                         chatInputContainer.innerHTML = `<div class="text-center p-4 py-6 text-sm text-gray-400 rounded-lg bg-[var(--background-tertiary)]">Please <button id="login-prompt-chat" class="text-purple-400 font-bold hover:underline">log in</button> to chat or interact.</div>`;
                         document.getElementById('login-prompt-chat')?.addEventListener('click', () => { loginModal.style.display = 'flex'; });
                     }
                     if (streamInfoPanel) streamInfoPanel.style.display = 'none';
                 } else {
                     setupFollowButton(streamerWallet);
                     setupSubscribeButton(streamerWallet);
                     setupVipEmojiPanel(streamerWallet);
                 }
                
                 unsubscribeStream = onSnapshot(doc(db, "streams", streamerWallet), (docSnap) => {
                     if (!docSnap.exists()) {
                         showToast(translations[currentLang].stream_ended);
                         renderExplorePage(); // Volver a explore si el stream ya no existe
                     } else {
                         const streamTitleDisplay = document.getElementById('stream-title-display');
                         if (streamTitleDisplay) streamTitleDisplay.textContent = docSnap.data().title || 'Untitled Stream';
                     }
                 }, error => {
                      console.error("Error listening to stream:", error);
                      showToast("Error loading stream info.", "error");
                      renderExplorePage(); // Volver a explore en caso de error
                 });
                
                 const chatMessages = document.getElementById('chat-messages');
                 const chatForm = document.getElementById('chat-form');
                 const chatInput = document.getElementById('chat-input');
                 const chatRef = collection(db, 'streams', streamerWallet, 'chat');
                 const q = query(chatRef, orderBy("createdAt", "desc"), limit(50));
                
                 unsubscribeChat = onSnapshot(q, async (snapshot) => {
                    if (!chatMessages) return; // Check if chatMessages exists
                     let newMessagesHtml = '';
                     snapshot.docChanges().reverse().forEach(async change => {
                         if (change.type === "added") {
                             const msg = change.doc.data();
                             let msgHtml = '';
                             if (msg.vipEmoji) {
                                 msgHtml = `<div class="super-chat"><div class="flex items-center gap-2 mb-2"><img src="${msg.vipEmoji.url}" class="w-10 h-10"><div class="font-bold text-lg">${msg.userName || 'User'} ${translations[currentLang].sent} ${msg.vipEmoji.price} BIT</div></div><p class="text-white text-md">${msg.text || ''}</p></div>`;
                             } else {
                                 let isSub = false;
                                 try {
                                     isSub = currentUser && msg.userWallet && (await getDoc(doc(db, "users", streamerWallet, "subscribers", msg.userWallet))).exists();
                                 } catch (e) { console.error("Error checking subscription:", e);}
                                 msgHtml = `<div class="text-sm"><p>${isSub ? '<svg class="member-badge" viewBox="0 0 24 24" fill="gold"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></svg>' : ''}<strong class="font-semibold" style="color: ${msg.userColor || '#FFFFFF'}">${msg.userName || 'User'}:</strong> ${msg.text || ''}</p></div>`;
                             }
                              newMessagesHtml += msgHtml; // Acumular HTML
                         }
                     });
                     if (newMessagesHtml) {
                          chatMessages.innerHTML += newMessagesHtml; // Añadir todos los mensajes nuevos
                          chatMessages.scrollTop = chatMessages.scrollHeight; // Hacer scroll una vez
                     }
                 }, error => console.error("Error listening to chat:", error));
                
                 if(chatForm) chatForm.addEventListener('submit', async (e) => { // Make async
                     e.preventDefault();
                     if (!requireAuth()) return;
                     const text = chatInput?.value.trim(); // Check if chatInput exists
                     if (text) {
                        try {
                             await addDoc(chatRef, { text, userName: currentUser.username, userWallet: currentUser.walletAddress, userColor: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'), createdAt: serverTimestamp() });
                             if(chatInput) chatInput.value = '';
                         } catch (error) {
                              console.error("Error sending chat message:", error);
                              showToast("Error sending message.", "error");
                         }
                     }
                 });
             }
            
             function cleanupWatchPage() {
                  if (mainContent) {
                      mainContent.classList.remove('!p-0', 'md:!p-0', '!overflow-hidden');
                      mainContent.classList.add('p-4', 'md:p-8');
                  }
                 if (unsubscribeChat) { unsubscribeChat(); unsubscribeChat = null; }
                 if (unsubscribeStream) { unsubscribeStream(); unsubscribeStream = null; }
                 if (viewerPeerConnection) {
                     viewerPeerConnection.close();
                     viewerPeerConnection = null;
                 }
                 if(adInterval) { clearInterval(adInterval); adInterval = null; }
             }


            
            // --- LÓGICA DE DEPÓSITO SOL (Automático con conversión a BIT) ---
            async function setupSolanaDeposit() {
                 // Verificar librerías al inicio
                 if (!await checkSolanaLibs('Setup Deposit')) return;

                // --- DOM ELEMENTS ---
                const amountInputSol = document.getElementById('deposit-amount-sol');
                const bitEstimateP = document.getElementById('bit-estimate');
                const generateQrBtnSol = document.getElementById('generate-qr-btn-sol');
                const payWithPhantomBtnSol = document.getElementById('pay-with-phantom-btn-sol');
                const depositFormSection = document.getElementById('deposit-form-section');
                const depositStatusSection = document.getElementById('deposit-status-section-sol'); // ID corregido
                const qrCodeContainerSol = document.getElementById('deposit-qr-code-sol'); // ID corregido
                const statusMessageSol = document.getElementById('deposit-status-message-sol'); // ID corregido
                const cancelBtnSol = document.getElementById('deposit-cancel-btn-sol'); // ID corregido
                const paymentSpinnerSol = document.getElementById('deposit-spinner-sol'); // ID corregido
                const depositTitleSol = document.getElementById('deposit-title-sol'); // ID corregido

                 // Validar existencia de elementos
                 if (!amountInputSol || !generateQrBtnSol || !payWithPhantomBtnSol || !cancelBtnSol || !depositStatusSection || !qrCodeContainerSol || !statusMessageSol || !paymentSpinnerSol || !depositTitleSol || !bitEstimateP) {
                     console.error("Deposit elements (SOL) not found!");
                     showToast("Error initializing deposit section.", "error");
                     return; 
                 }

                let pollingInterval = null;
                let currentReference = null; // Guardar la referencia Keypair actual
                let currentExpectedSol = 0; // Guardar el monto SOL esperado

                 // Función para obtener precio SOL/BIT y actualizar estimado
                 const updateBitEstimate = async () => {
                     const solAmount = parseFloat(amountInputSol.value);
                     if (isNaN(solAmount) || solAmount <= 0) {
                         bitEstimateP.textContent = '';
                         return;
                     }
                      bitEstimateP.textContent = 'Fetching price...'; // Indicar carga
                     try {
                         const bitPriceData = await fetchBitPriceVsSol();
                         if (!bitPriceData || bitPriceData.priceSol <= 0) { // Validar precio > 0
                             bitEstimateP.textContent = 'Could not fetch price';
                             return;
                         }
                         const bitAmount = (solAmount / bitPriceData.priceSol);
                          // Mostrar más decimales para BIT si es necesario
                          const displayBitAmount = bitAmount >= 1 ? bitAmount.toFixed(2) : bitAmount.toFixed(6); 
                         bitEstimateP.textContent = `≈ ${displayBitAmount} BIT`;
                     } catch (error) {
                         console.error("Error updating BIT estimate:", error);
                         bitEstimateP.textContent = 'Error fetching price';
                     }
                 };

                 // Actualizar estimado al escribir en el input (con debounce)
                 let debounceTimer;
                 amountInputSol.addEventListener('input', () => {
                     clearTimeout(debounceTimer);
                     debounceTimer = setTimeout(updateBitEstimate, 500); // Esperar 500ms antes de calcular
                 });

                const resetToInitialState = () => {
                    if (pollingInterval) clearInterval(pollingInterval);
                    pollingInterval = null;
                    currentReference = null;
                    currentExpectedSol = 0;
                    if(amountInputSol) amountInputSol.value = '';
                     if(bitEstimateP) bitEstimateP.textContent = ''; // Limpiar estimado
                    if(generateQrBtnSol) generateQrBtnSol.disabled = false;
                    if(payWithPhantomBtnSol) payWithPhantomBtnSol.disabled = false;
                    if(depositFormSection) depositFormSection.classList.remove('hidden');
                    if(depositStatusSection) depositStatusSection.classList.add('hidden');
                    if(qrCodeContainerSol) qrCodeContainerSol.innerHTML = '';
                    if(statusMessageSol) statusMessageSol.textContent = 'Esperando pago de SOL...';
                };

                 // Función para obtener el precio BIT/SOL desde Dexscreener
                 const fetchBitPriceVsSol = async () => {
                     try {
                         // Busca pares del token BIT contra SOL (So1111...)
                         const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${BIT_TOKEN_MINT}`);
                         if (!response.ok) throw new Error(`Dexscreener API request failed with status ${response.status}`);
                         const data = await response.json();
                         
                         // Buscar el par específico contra SOL
                         const solPair = data.pairs?.find(p => p.quoteToken.address === 'So11111111111111111111111111111111111111112'); // Dirección de Wrapped SOL
                         
                         if (solPair && solPair.priceNative) { // priceNative suele ser el precio en la moneda quote (SOL en este caso)
                             const priceSol = parseFloat(solPair.priceNative);
                             const priceUsd = parseFloat(solPair.priceUsd); // Precio en USD como referencia
                             if (!isNaN(priceSol) && priceSol > 0) { // Validar que el precio sea > 0
                                 console.log(`BIT Price: ${priceSol.toFixed(9)} SOL / ${priceUsd ? `$${priceUsd.toFixed(6)}` : 'N/A USD'}`);
                                 return { priceSol, priceUsd }; // Retorna el precio en SOL y USD
                             }
                         }
                         console.warn("Could not find a valid SOL pair for BIT token on Dexscreener or price is invalid/zero.");
                         return null;
                     } catch (error) {
                         console.error("Error fetching BIT price vs SOL:", error);
                         return null;
                     }
                 };


                 const finalizeDeposit = async (signature, solAmountPaid) => {
                     if (statusMessageSol) statusMessageSol.textContent = 'Pago SOL recibido! Calculando BIT...';
                     if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'block';

                     try {
                         // 1. Obtener el precio SOL/BIT
                         const bitPriceData = await fetchBitPriceVsSol();
                         if (!bitPriceData || bitPriceData.priceSol <= 0) {
                             throw new Error("Could not fetch BIT/SOL price for conversion.");
                         }

                         // 2. Calcular la cantidad de BIT
                         const bitAmount = Math.floor(solAmountPaid / bitPriceData.priceSol); // Usar Math.floor para asegurar entero

                         if (isNaN(bitAmount) || bitAmount <= 0) {
                             throw new Error(`Invalid calculated BIT amount: ${bitAmount}`);
                         }

                         // 3. Actualizar Firestore
                         if (statusMessageSol) statusMessageSol.textContent = `Acreditando ${bitAmount.toLocaleString()} BIT...`;
                         if (!currentUser?.walletAddress) throw new Error("User not logged in or wallet address missing."); // Validar currentUser
                         const userRef = doc(db, "users", currentUser.walletAddress);
                         await updateDoc(userRef, { bitBalance: increment(bitAmount) });

                         // 4. Registrar la transacción (opcional pero recomendado)
                         await addDoc(collection(db, "solDeposits"), {
                            userWallet: currentUser.walletAddress,
                            solAmount: solAmountPaid,
                            bitAmountCredited: bitAmount,
                            solPriceUsdAtDeposit: bitPriceData.priceUsd || null, // Guardar precio USD si está disponible
                            bitPriceSolAtDeposit: bitPriceData.priceSol,
                            transactionSignature: signature,
                            reference: currentReference?.publicKey.toBase58() || null, // Guardar referencia si existe
                            status: "completed",
                            processedAt: serverTimestamp()
                         });

                         if (statusMessageSol) statusMessageSol.textContent = `¡Depósito Confirmado! +${bitAmount.toLocaleString()} BIT`;
                         if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'none';
                         showToast(`+${bitAmount.toLocaleString()} BIT added to your balance.`);
                        
                         // Refrescar datos del usuario y header (renderHeader ahora maneja currentUser null)
                         renderHeader(); 
                         await updateWithdrawalStatus(); // Actualizar info de retiro

                     } catch (error) {
                         console.error("Error finalizing deposit (SOL->BIT):", error);
                         if (statusMessageSol) statusMessageSol.textContent = 'Error al convertir/acreditar BIT.';
                         if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'none';
                         showToast("Error processing deposit. Please contact support.", 'error');
                         // Opcional: Registrar el error en Firestore para seguimiento
                         try {
                              await addDoc(collection(db, "depositErrors"), {
                                   userWallet: currentUser?.walletAddress || 'unknown',
                                   solAmount: solAmountPaid,
                                   signature: signature,
                                   reference: currentReference?.publicKey.toBase58() || null,
                                   error: error.message || String(error),
                                   timestamp: serverTimestamp()
                              });
                         } catch (logError) {
                              console.error("Failed to log deposit error:", logError);
                         }
                     } finally {
                         setTimeout(resetToInitialState, 5000); // Volver al formulario después de 5 seg
                     }
                 };

                // Escucha para transacciones (QR o Phantom referenciada)
                const listenForTransaction = (referencePublicKey, amountSol) => {
                     if (!solanaConnection) { // Asegurar conexión
                          showToast("Solana connection not ready.", "error");
                          resetToInitialState();
                          return;
                     }
                     currentReference = { publicKey: referencePublicKey }; // Guardar referencia actual
                     currentExpectedSol = amountSol; // Guardar monto SOL esperado

                     if (statusMessageSol) statusMessageSol.textContent = 'Esperando confirmación de la transacción SOL...';
                     if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'block';
                    
                      let attempts = 0; // Contador de intentos
                      const maxAttempts = 12; // Máximo ~2 minutos (12 * 10s)

                     const checkSignature = async () => {
                         if (attempts >= maxAttempts) {
                              console.warn(`Max polling attempts reached for reference: ${referencePublicKey.toBase58()}`);
                              if (statusMessageSol) statusMessageSol.textContent = 'Verification timed out. Please check your wallet.';
                              if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'none';
                              if (pollingInterval) clearInterval(pollingInterval);
                              pollingInterval = null;
                              setTimeout(resetToInitialState, 5000);
                              return;
                         }
                         attempts++;
                         console.log(`Polling attempt ${attempts}/${maxAttempts} for signature with reference: ${referencePublicKey.toBase58().substring(0, 10)}...`);
                         
                         try {
                             // Buscar la firma usando la referencia como cuenta (Solana Pay standard)
                             const signatures = await solanaConnection.getSignaturesForAddress(referencePublicKey, { limit: 1 });
                            
                             if (signatures.length > 0) {
                                 const sigInfo = signatures[0];
                                 const signature = sigInfo.signature;
                                 console.log("Signature found:", signature);

                                 if (pollingInterval) clearInterval(pollingInterval); // Detener polling
                                 pollingInterval = null;

                                 if (statusMessageSol) statusMessageSol.textContent = 'Verificando transacción SOL...';

                                 // Obtener detalles de la transacción para verificar monto
                                 // Aumentar timeout para getTransaction
                                 const tx = await solanaConnection.getTransaction(signature, { 
                                      maxSupportedTransactionVersion: 0,
                                      commitment: 'confirmed' 
                                 }); 
                                 
                                 if (!tx) {
                                      // Si no se encuentra con 'confirmed', intentar 'finalized' como fallback
                                      console.warn("Transaction not found with 'confirmed', trying 'finalized'...");
                                      await delay(2000); // Esperar un poco más
                                      const txFinalized = await solanaConnection.getTransaction(signature, { 
                                           maxSupportedTransactionVersion: 0,
                                           commitment: 'finalized' 
                                      });
                                      if (!txFinalized) throw new Error("Transaction details not found even after finalized check.");
                                      if (txFinalized.meta?.err) throw new Error(`Transaction failed (finalized): ${JSON.stringify(txFinalized.meta.err)}`);
                                      // Continuar con txFinalized si se encontró
                                      console.log("Transaction found with 'finalized'.");
                                      // Re-validar monto con txFinalized
                                      // ... (código de validación de monto repetido aquí o refactorizado) ...
                                      // Por simplicidad, asumimos que si se encuentra 'finalized', es válida y continuamos
                                       let solTransferredFinalized = 0; // Recalcular con txFinalized
                                       const preBalancesF = txFinalized.meta?.preBalances || [];
                                       const postBalancesF = txFinalized.meta?.postBalances || [];
                                       const accountIndexF = txFinalized.transaction.message.accountKeys.findIndex(key => key.toBase58() === DEPOSIT_DESTINATION_WALLET);
                                      if (accountIndexF !== -1 && preBalancesF.length > accountIndexF && postBalancesF.length > accountIndexF) {
                                           solTransferredFinalized = (postBalancesF[accountIndexF] - preBalancesF[accountIndexF]) / window.solanaWeb3.LAMPORTS_PER_SOL;
                                      } // (Podría añadirse fallback a instrucciones aquí también)
                                      
                                      const tolerance = 0.00001;
                                      if (Math.abs(solTransferredFinalized - amountSol) > tolerance) {
                                          throw new Error(`Amount mismatch (finalized): Expected ${amountSol} SOL, received ${solTransferredFinalized} SOL.`);
                                      }
                                      console.log("SOL Transaction (finalized) confirmed and amount verified.");
                                      await finalizeDeposit(signature, solTransferredFinalized);
                                      return; // Salir de la función si se procesó con finalized
                                      
                                 } else if (tx.meta?.err) {
                                      throw new Error(`Transaction failed (confirmed): ${JSON.stringify(tx.meta.err)}`);
                                 }


                                 // Verificar el monto de SOL transferido a la wallet de destino (con tx 'confirmed')
                                 let solTransferred = 0;
                                 const destinationPubkeyStr = DEPOSIT_DESTINATION_WALLET;
                                 
                                 const preBalances = tx.meta?.preBalances || [];
                                 const postBalances = tx.meta?.postBalances || [];
                                 const accountIndex = tx.transaction.message.accountKeys.findIndex(key => key.toBase58() === destinationPubkeyStr);
                                 
                                 if (accountIndex !== -1 && preBalances.length > accountIndex && postBalances.length > accountIndex) {
                                      solTransferred = (postBalances[accountIndex] - preBalances[accountIndex]) / window.solanaWeb3.LAMPORTS_PER_SOL;
                                      console.log(`SOL transferred to destination (Balance Change): ${solTransferred}`);
                                 } else {
                                     console.warn("Could not determine SOL transfer from balance changes, checking instructions...");
                                     tx.transaction.message.instructions.forEach(ix => {
                                         try {
                                             if (ix.programId.equals(window.solanaWeb3.SystemProgram.programId)) {
                                                  const decoded = window.solanaWeb3.SystemInstruction.decodeTransfer(ix);
                                                  if (decoded.toPubkey.toBase58() === destinationPubkeyStr) {
                                                       solTransferred = decoded.lamports / window.solanaWeb3.LAMPORTS_PER_SOL;
                                                       console.log(`SOL transferred to destination (Instruction): ${solTransferred}`);
                                                  }
                                             }
                                         } catch (decodeError) { /* Ignorar */ }
                                     });
                                 }

                                 const tolerance = 0.00001; 
                                 if (Math.abs(solTransferred - amountSol) > tolerance) {
                                     throw new Error(`Amount mismatch: Expected ${amountSol} SOL, received ${solTransferred} SOL.`);
                                 }

                                 console.log("SOL Transaction (confirmed) confirmed and amount verified.");
                                 await finalizeDeposit(signature, solTransferred); 

                             } else {
                                console.log("Signature not found yet...");
                                // No hacer nada, esperar al siguiente intervalo
                             }
                         } catch (error) {
                             console.error("Error polling/verifying transaction:", error);
                             if (error.message && (error.message.includes('429') || error.message.includes('rate limited'))) {
                                 if (statusMessageSol) statusMessageSol.textContent = 'Verificación lenta (límite red). Reintentando...';
                                 // No detener polling por rate limit, pero quizás aumentar el intervalo?
                             } else if (error.message && error.message.includes('Transaction details not found')) {
                                  // No es un error fatal aún, podría aparecer más tarde
                                  console.warn("Transaction details not found yet, continuing polling...");
                             } else {
                                 // Error más serio
                                 if (statusMessageSol) statusMessageSol.textContent = 'Error verificando pago: ' + error.message.substring(0, 50); // Mensaje más corto
                                 if (paymentSpinnerSol) paymentSpinnerSol.style.display = 'none';
                                 if (pollingInterval) clearInterval(pollingInterval);
                                 pollingInterval = null;
                                  setTimeout(resetToInitialState, 5000); // Resetear después de 5s en caso de error
                             }
                         }
                     };
                     
                     // Iniciar polling inmediatamente y luego cada 10 segundos
                     checkSignature(); 
                     pollingInterval = setInterval(checkSignature, 10000); // Intervalo de 10 segundos
                 };

                const getPhantomProvider = () => {
                    if ('phantom' in window && window.phantom.solana?.isPhantom) {
                         return window.phantom.solana;
                    }
                    return null;
                };

                 const handlePhantomPay = async () => {
                     if (!await checkSolanaLibs('Phantom Pay SOL') || !solanaConnection) return;

                     const solAmount = parseFloat(amountInputSol.value);
                     if (isNaN(solAmount) || solAmount <= 0) {
                         showToast("Please enter a valid SOL amount.", "error");
                         if(amountInputSol) {
                             amountInputSol.classList.add('ring-2', 'ring-red-500');
                             setTimeout(() => amountInputSol.classList.remove('ring-2', 'ring-red-500'), 2000);
                         }
                         return;
                     }
                    
                     const provider = getPhantomProvider();
                     if (!provider) {
                         showToast('Phantom wallet not detected. Please install Phantom.', 'error');
                         return;
                     }

                     if(generateQrBtnSol) generateQrBtnSol.disabled = true;
                     if(payWithPhantomBtnSol) payWithPhantomBtnSol.disabled = true;
                     if(depositFormSection) depositFormSection.classList.add('hidden');
                     if(depositStatusSection) depositStatusSection.classList.remove('hidden');
                     if(qrCodeContainerSol) {
                          qrCodeContainerSol.innerHTML = ''; 
                          qrCodeContainerSol.classList.add('hidden'); 
                     }
                     if(depositTitleSol) depositTitleSol.textContent = "Confirm in Phantom";
                     if(statusMessageSol) statusMessageSol.textContent = 'Connecting to Phantom...';
                     if(paymentSpinnerSol) paymentSpinnerSol.style.display = 'block';

                     try {
                         // Solicitar conexión si no está conectado
                         if (!provider.isConnected) {
                             await provider.connect({ onlyIfTrusted: false }); 
                         }
                        
                         if (!provider.publicKey) throw new Error("Phantom connection rejected or not available.");
                        
                         if(statusMessageSol) statusMessageSol.textContent = 'Creating SOL transaction...';

                         const fromWallet = provider.publicKey;
                         const toWallet = new window.solanaWeb3.PublicKey(DEPOSIT_DESTINATION_WALLET); 
                         const lamports = Math.round(solAmount * window.solanaWeb3.LAMPORTS_PER_SOL);
                         
                         const referenceKeypair = window.solanaWeb3.Keypair.generate();
                         
                         const transaction = new window.solanaWeb3.Transaction().add(
                             window.solanaWeb3.SystemProgram.transfer({
                                 fromPubkey: fromWallet,
                                 toPubkey: toWallet,
                                 lamports: lamports,
                             }),
                             new window.solanaWeb3.TransactionInstruction({
                                 keys: [{ pubkey: fromWallet, isSigner: true, isWritable: true }],
                                 programId: new window.solanaWeb3.PublicKey("MemoSq4gqABAXKb96qnH8TysNcVtrp5GzAicDHckD"), 
                                 data: Buffer.from(`Ref:${referenceKeypair.publicKey.toBase58()}`, "utf-8"), 
                             })
                         );
                        
                         transaction.feePayer = fromWallet;
                         const latestBlockhash = await solanaConnection.getLatestBlockhash('confirmed');
                         transaction.recentBlockhash = latestBlockhash.blockhash;
                         // No necesitamos lastValidBlockHeight para signAndSend

                         if(statusMessageSol) statusMessageSol.textContent = 'Please confirm in Phantom wallet...';
                         
                         const { signature } = await provider.signAndSendTransaction(transaction);
                         console.log("SOL Transaction sent via Phantom:", signature);
                         
                         if(statusMessageSol) statusMessageSol.textContent = 'Transaction sent! Waiting for confirmation...';
                         
                         // Iniciar la escucha usando la referencia generada
                         listenForTransaction(referenceKeypair.publicKey, solAmount);

                     } catch (err) {
                         console.error("Phantom SOL payment error:", err);
                         let userMessage = "Phantom SOL payment failed.";
                         if (err.code === 4001 || (err.message && err.message.includes("User rejected the request"))) {
                             userMessage = "Transaction cancelled by user.";
                         } else if (err.message && (err.message.includes("RPC request failed") || err.message.includes("Network error"))) {
                              userMessage = "Network error sending transaction.";
                         } else if (err.message) {
                             userMessage = `Error: ${err.message.split(".")[0].substring(0, 100)}`; 
                         }
                          showToast(userMessage, 'error');
                         resetToInitialState();
                     }
                 };
                
                 const handleQrPay = async () => { 
                     if (!await checkSolanaLibs('QR Pay SOL') || !solanaConnection) return;
                     // Cargar QRCode si no está listo
                     if (typeof QRCode === 'undefined') {
                          let qrAttempts = 0;
                          while (typeof QRCode === 'undefined' && qrAttempts < 10) {
                              console.log("Waiting for QRCode library...");
                              await delay(300);
                              qrAttempts++;
                          }
                          if (typeof QRCode === 'undefined') {
                               showToast("QR Code library failed to load.", "error");
                               return;
                          }
                     }

                     const solAmount = parseFloat(amountInputSol.value);
                     if (isNaN(solAmount) || solAmount <= 0) {
                         showToast("Please enter a valid SOL amount.", "error");
                         if(amountInputSol) {
                              amountInputSol.classList.add('ring-2', 'ring-red-500');
                              setTimeout(() => amountInputSol.classList.remove('ring-2', 'ring-red-500'), 2000);
                         }
                         return;
                     }

                     if(generateQrBtnSol) generateQrBtnSol.disabled = true;
                     if(payWithPhantomBtnSol) payWithPhantomBtnSol.disabled = true;

                     const reference = window.solanaWeb3.Keypair.generate(); 
                     const label = 'Deposit LivePayout (SOL)';
                     const message = `Pay ${solAmount} SOL for BIT. Ref: ${reference.publicKey.toBase58().substring(0,6)}`;
                     const solanaPayUrl = `solana:${DEPOSIT_DESTINATION_WALLET}?amount=${solAmount}&reference=${reference.publicKey.toBase58()}&label=${encodeURIComponent(label)}&message=${encodeURIComponent(message)}`;
                    
                     if(qrCodeContainerSol) qrCodeContainerSol.innerHTML = ''; 
                     try {
                         const canvas = await QRCode.toCanvas(solanaPayUrl, { width: 192, errorCorrectionLevel: 'H', color: { dark: '#FFFFFF', light: '#1F2937' } });
                         if(qrCodeContainerSol) { 
                             canvas.style.borderRadius = '0.5rem';
                             canvas.style.border = '8px solid #374151'; 
                             qrCodeContainerSol.appendChild(canvas);
                         }
                         
                         if(depositFormSection) depositFormSection.classList.add('hidden');
                         if(depositStatusSection) depositStatusSection.classList.remove('hidden');
                         if(qrCodeContainerSol) qrCodeContainerSol.classList.remove('hidden'); 
                         if(depositTitleSol) depositTitleSol.textContent = "Scan QR to Pay SOL";
                         if(statusMessageSol) statusMessageSol.textContent = 'Waiting for SOL payment...';
                         if(paymentSpinnerSol) paymentSpinnerSol.style.display = 'block';

                         listenForTransaction(reference.publicKey, solAmount);

                     } catch (err) {
                          console.error("Error generating SOL QR code:", err);
                          showToast("Error generating QR code.", "error");
                          resetToInitialState();
                     }
                 };

                 // Asignar eventos a los botones correctos
                 payWithPhantomBtnSol.addEventListener('click', handlePhantomPay);
                 generateQrBtnSol.addEventListener('click', handleQrPay);
                 cancelBtnSol.addEventListener('click', resetToInitialState);
            }
            // --- FIN DE LA LÓGICA DE DEPÓSITO SOL ---

            // --- Funciones de Profile/Withdrawal ---
            function attachAnalyticsListeners() { // Mover antes de su uso
                 if (!currentUser) return;
                 const transferBtn = document.getElementById("transfer-rewards");
                 if (transferBtn) { 
                     // Deshabilitar botón basado en el balance actual
                     transferBtn.disabled = (currentUser.creatorRewardsBalance || 0) <= 0;
                     
                     // Añadir listener solo si no existe ya (evitar duplicados)
                     if (!transferBtn.dataset.listenerAttached) {
                         transferBtn.addEventListener("click", async () => {
                             if((currentUser.creatorRewardsBalance || 0) <= 0) return; // Re-verificar balance al hacer clic
                             if(loader) loader.classList.remove("hidden"); 
                             try {
                                 const userRef = doc(db, "users", currentUser.walletAddress);
                                 const amount = currentUser.creatorRewardsBalance; // Guardar monto antes de la transacción
                                 await updateDoc(userRef, { 
                                     bitBalance: increment(amount), 
                                     creatorRewardsBalance: 0 // Poner a cero directamente
                                 });
                                 showToast(translations[currentLang].rewards_transferred.replace('%a', amount.toLocaleString()));
                                 transferBtn.disabled = true; // Deshabilitar después de transferir
                             } catch (error) {
                                  console.error("Error transferring rewards:", error);
                                  showToast("Error transferring rewards.", "error");
                             } finally {
                                 if(loader) loader.classList.add("hidden");
                             }
                         });
                         transferBtn.dataset.listenerAttached = 'true';
                     }
                 }
             }

             async function saveProfile() {
                 const profilePicUrlInput = document.getElementById("profile-pic-url");
                 const usernameInput = document.getElementById("username-input");
                 if (!profilePicUrlInput || !usernameInput || !currentUser) return; // Check elements and user exist

                 const newPicUrl = profilePicUrlInput.value.trim();
                 const newUsername = usernameInput.value.trim();
                 const updates = {};
                 
                  // Simple URL validation (basic)
                 const urlRegex = /^https?:\/\/.+\..+/;
                 if (newPicUrl && newPicUrl !== currentUser.profilePicture) {
                      if (urlRegex.test(newPicUrl)) {
                           updates.profilePicture = newPicUrl;
                      } else {
                           showToast("Invalid Profile Picture URL format.", "error");
                           return; // Detener si la URL es inválida
                      }
                 }
                 if (newUsername && newUsername !== currentUser.username) {
                     // Añadir validación de longitud o caracteres si es necesario
                     if (newUsername.length > 3 && newUsername.length < 25) {
                          updates.username = newUsername;
                     } else {
                           showToast("Username must be between 4 and 24 characters.", "error");
                           return; // Detener si el nombre de usuario es inválido
                     }
                 }
                 
                 if (Object.keys(updates).length > 0) {
                    if(loader) loader.classList.remove("hidden");
                     try {
                         await updateDoc(doc(db, "users", currentUser.walletAddress), updates);
                         showToast(translations[currentLang].profile_updated);
                     } catch (error) {
                          console.error("Error updating profile:", error);
                          showToast("Error updating profile.", "error");
                     } finally {
                         if(loader) loader.classList.add("hidden");
                     }
                 } else {
                      showToast("No changes to save.", "info");
                 }
             }

             const TOKEN_CONTRACT = "EU1CPckq2dRX2HXUdy7hZvhuwmx9DN3afSHL5wTopump";
             let currentBitPriceUsd = null; // Guardar precio para usar en estimación

             async function updateWithdrawalStatus() { // Ahora también actualiza bit-estimate si está visible
                 const usdEquivalentDisplay = document.getElementById("usd-equivalent-display");
                 const tokenPriceInfo = document.getElementById("token-price-info");
                 const withdrawButton = document.getElementById("withdraw-button");
                 const withdrawalInfoText = document.getElementById("withdrawal-info-text");
                 const bitEstimateP = document.getElementById('bit-estimate'); // Para actualizar si es necesario

                 if (!currentUser || !withdrawalInfoText || !withdrawButton || !usdEquivalentDisplay || !tokenPriceInfo) return; 

                 // Obtener precio BIT/USD (usaremos el mismo endpoint que BIT/SOL)
                 if (currentBitPriceUsd === null) { // Obtener solo si no lo tenemos
                     try {
                         const bitPriceData = await fetchBitPriceVsSol(); // Reutilizar función
                         if (bitPriceData && bitPriceData.priceUsd > 0) {
                             currentBitPriceUsd = bitPriceData.priceUsd;
                             tokenPriceInfo.textContent = `1 BIT \u2248 $${currentBitPriceUsd.toFixed(6)} USD`;
                         } else {
                             throw new Error("Invalid price data from API.");
                         }
                     } catch (e) {
                         console.error("Error fetching token price for withdrawal:", e.message);
                         usdEquivalentDisplay.textContent = translations[currentLang].price_fetch_error;
                         tokenPriceInfo.textContent = '';
                         currentBitPriceUsd = 0; // Marcar como fallido para no reintentar constantemente
                         // Considerar detener el intervalo si falla repetidamente
                         // if (withdrawalUpdateInterval) { clearInterval(withdrawalUpdateInterval); withdrawalUpdateInterval = null; }
                     }
                 }

                 // Calcular valor USD del balance
                 if (currentBitPriceUsd > 0) {
                     const balanceUsd = (currentUser.bitBalance || 0) * currentBitPriceUsd;
                     usdEquivalentDisplay.textContent = `~ $${balanceUsd.toFixed(2)} USD`;
                 } else if (currentBitPriceUsd === 0) { // Si falló la obtención
                     usdEquivalentDisplay.textContent = translations[currentLang].price_fetch_error;
                 } else { // Si aún no se obtiene (null)
                      usdEquivalentDisplay.textContent = 'Calculating...';
                 }

                 // Actualizar estado del botón de retiro
                 const canWithdraw = (currentUser.bitBalance || 0) >= WITHDRAWAL_MINIMUM_BIT;
                 withdrawButton.disabled = !canWithdraw;
                 if (canWithdraw) {
                     withdrawalInfoText.textContent = translations[currentLang].withdrawal_ready;
                 } else {
                     const neededBits = WITHDRAWAL_MINIMUM_BIT - (currentUser.bitBalance || 0);
                     withdrawalInfoText.textContent = translations[currentLang].need_more_to_withdraw.replace('%a', neededBits.toLocaleString());
                 }

                 // Actualizar bit-estimate si la sección de depósito está visible y hay un precio
                 if (bitEstimateP && !depositFormSection?.classList.contains('hidden') && currentBitPriceUsd > 0) {
                      // Se necesita el precio SOL/USD también, o recalcular SOL/BIT
                      // Por ahora, lo dejamos como está (se actualiza al escribir en input SOL)
                      // updateBitEstimate(); // Podría llamarse aquí si tuviéramos precio SOL/USD
                 }
             }
            
             async function requestWithdrawal() {
                 const withdrawButton = document.getElementById("withdraw-button");
                 const withdrawMessage = document.getElementById("withdraw-message");
                 if (!withdrawButton || withdrawButton.disabled || !withdrawMessage || !currentUser) return; 

                 if((currentUser.bitBalance || 0) < WITHDRAWAL_MINIMUM_BIT) {
                      showToast(`You need at least ${WITHDRAWAL_MINIMUM_BIT.toLocaleString()} BIT.`, "error");
                      return;
                 }

                 if(loader) loader.classList.remove("hidden");
                 withdrawMessage.textContent = translations[currentLang].processing;
                 withdrawMessage.classList.remove("text-green-500", "text-red-500"); 

                 const amountToWithdraw = currentUser.bitBalance; // Guardar el monto antes de ponerlo a cero

                 try {
                      const userRef = doc(db, "users", currentUser.walletAddress);
                      // Poner balance a cero ANTES de crear la solicitud para evitar doble retiro
                      await updateDoc(userRef, { bitBalance: 0 }); 
                      
                      // Crear la solicitud
                      await addDoc(collection(db, "withdrawalRequests"), {
                          userWallet: currentUser.walletAddress, 
                          username: currentUser.username, 
                          amount: amountToWithdraw, // Usar el monto guardado
                          status: "pending", 
                          requestedAt: serverTimestamp()
                      });

                     withdrawMessage.textContent = translations[currentLang].withdrawal_requested;
                     withdrawMessage.classList.add("text-green-500");
                     showToast(translations[currentLang].withdrawal_requested_toast);
                     // Refrescar estado (ya se hizo updateDoc, onSnapshot debería actualizar currentUser)
                     // updateWithdrawalStatus(); // No es estrictamente necesario, pero asegura UI
                 } catch (error) {
                     console.error("Error creating withdrawal request:", error);
                     withdrawMessage.textContent = translations[currentLang].withdrawal_error;
                     withdrawMessage.classList.add("text-red-500");
                     // IMPORTANTE: Intentar devolver el balance si la creación de la solicitud falla
                     try {
                          await updateDoc(doc(db, "users", currentUser.walletAddress), { bitBalance: amountToWithdraw });
                          showToast("Withdrawal failed. Your balance has been restored.", "error");
                     } catch (restoreError) {
                          console.error("CRITICAL: Failed to restore balance after withdrawal error:", restoreError);
                          showToast("CRITICAL ERROR during withdrawal. Please contact support.", "error");
                          // Aquí se necesitaría intervención manual
                     }
                 } finally {
                    if(loader) loader.classList.add("hidden");
                 }
             }

             // --- Funciones de Follow/Subscribe/VIP Emoji ---
             async function setupFollowButton(streamerWallet) {
                 const followBtn = document.getElementById('follow-btn');
                 if (!currentUser || !followBtn || streamerWallet === currentUser.walletAddress) { // No seguirse a sí mismo
                      if (followBtn) followBtn.style.display = 'none'; // Ocultar botón
                      return; 
                 } else {
                      if (followBtn) followBtn.style.display = 'block'; // Asegurar que sea visible
                 }
                 
                 const myFollowingRef = doc(db, 'users', currentUser.walletAddress, 'following', streamerWallet);
                 let unsubscribeFollow = null; // Variable local

                 const updateButtonState = (isFollowing) => {
                     if (!followBtn) return;
                     followBtn.disabled = false; // Habilitar por defecto
                     followBtn.classList.remove('purple-gradient-bg', 'bg-transparent', 'border', 'border-[var(--brand-color-purple)]', 'text-[var(--brand-color-purple)]', 'bg-gray-700', 'hover:bg-gray-600');
                     followBtn.classList.add('text-white'); // Asegurar texto blanco por defecto
                     if (isFollowing) {
                         followBtn.textContent = translations[currentLang].unfollow;
                         followBtn.classList.add('bg-transparent', 'border', 'border-[var(--brand-color-purple)]', 'text-[var(--brand-color-purple)]');
                         followBtn.classList.remove('text-white');
                     } else {
                         followBtn.textContent = translations[currentLang].follow;
                         followBtn.classList.add('bg-gray-700', 'hover:bg-gray-600');
                     }
                 };
                
                 // Listener para estado de seguimiento
                  unsubscribeFollow = onSnapshot(myFollowingRef, (docSnap) => {
                     updateButtonState(docSnap.exists());
                 }, error => {
                      console.error("Error listening to follow status:", error);
                      if (followBtn) followBtn.disabled = true; // Deshabilitar si hay error
                 });

                 // Añadir listener de clic solo una vez
                 if (!followBtn.dataset.listenerAttached) {
                     followBtn.onclick = async () => {
                         if (!requireAuth()) return;
                         followBtn.disabled = true; // Deshabilitar mientras procesa

                         try {
                             const isCurrentlyFollowing = (await getDoc(myFollowingRef)).exists();
                             const streamerFollowersRef = doc(db, 'users', streamerWallet, 'followers', currentUser.walletAddress);
                             const myUserRef = doc(db, 'users', currentUser.walletAddress);
                             const streamerUserRef = doc(db, 'users', streamerWallet);

                             const streamerSnap = await getDoc(streamerUserRef);
                             const streamerUsername = streamerSnap.data()?.username || streamerWallet.substring(0,6);
                             const incrementValue = isCurrentlyFollowing ? -1 : 1;

                             await runTransaction(db, async (t) => { 
                                 if (isCurrentlyFollowing) {
                                     t.delete(myFollowingRef); 
                                     t.delete(streamerFollowersRef); 
                                 } else {
                                     t.set(myFollowingRef, { followedAt: serverTimestamp() }); 
                                     t.set(streamerFollowersRef, { followerAt: serverTimestamp() }); 
                                 }
                                 t.update(myUserRef, { followingCount: increment(incrementValue) }); 
                                 t.update(streamerUserRef, { followersCount: increment(incrementValue) }); 
                             });
                             showToast(isCurrentlyFollowing 
                                ? translations[currentLang].unfollowed_user.replace('%s', streamerUsername) 
                                : translations[currentLang].followed_user.replace('%s', streamerUsername)
                             );
                         } catch (error) { 
                             console.error("Follow/unfollow transaction error:", error); 
                             showToast(translations[currentLang].action_error, "error"); 
                             // Re-habilitar botón en caso de error
                             followBtn.disabled = false; 
                         } 
                         // No necesitamos re-habilitar aquí porque onSnapshot lo hará
                     };
                     followBtn.dataset.listenerAttached = 'true';
                 }

                  // Guardar función de desuscripción para limpieza
                  followBtn.unsubscribeFollowListener = unsubscribeFollow;
             }
            
             async function setupSubscribeButton(streamerWallet) {
                 const subBtn = document.getElementById('subscribe-btn');
                  if (!currentUser || !subBtn || streamerWallet === currentUser.walletAddress) { // No suscribirse a sí mismo
                       if (subBtn) subBtn.style.display = 'none';
                       return; 
                  } else {
                       if (subBtn) subBtn.style.display = 'flex'; // Asegurar visibilidad (es flex)
                  }

                 const subRef = doc(db, 'users', streamerWallet, 'subscribers', currentUser.walletAddress);
                 let isSubscribed = false; // Estado local

                 const updateButtonState = (subscribed) => {
                      if (!subBtn) return;
                      isSubscribed = subscribed;
                      subBtn.disabled = subscribed; // Deshabilitar si ya está suscrito
                      if (subscribed) {
                           subBtn.innerHTML = `<i data-lucide="check"></i> <span data-key="subscribed">${translations[currentLang].subscribed}</span>`;
                           subBtn.classList.remove('purple-gradient-bg', 'hover:opacity-90');
                           subBtn.classList.add('bg-gray-600', 'cursor-not-allowed'); // Estilo deshabilitado
                      } else {
                           subBtn.innerHTML = `<i data-lucide="star" class="w-4 h-4"></i> <span data-key="subscribe">${translations[currentLang].subscribe}</span> (100 BIT)`;
                           subBtn.classList.add('purple-gradient-bg', 'hover:opacity-90');
                           subBtn.classList.remove('bg-gray-600', 'cursor-not-allowed');
                      }
                      lucide.createIcons();
                 };

                 // Verificar estado inicial
                 try {
                     const subSnap = await getDoc(subRef);
                     updateButtonState(subSnap.exists());
                 } catch(e) { console.error("Error checking initial subscription status:", e); }

                 // Añadir listener de clic solo una vez
                  if (!subBtn.dataset.listenerAttached) {
                     subBtn.onclick = async () => {
                         if (!requireAuth() || isSubscribed) return; // Salir si no logueado o ya suscrito
                         
                         const currentBalance = currentUser.bitBalance || 0;
                         if (currentBalance < 100) {
                              showToast(translations[currentLang].insufficient_bits_subscribe, "error");
                              return;
                         }

                         subBtn.disabled = true; // Deshabilitar mientras procesa
                         if(loader) loader.classList.remove('hidden');
                         
                         try {
                             const streamerUserRef = doc(db, "users", streamerWallet);
                             const streamerSnap = await getDoc(streamerUserRef); 
                             const streamerUsername = streamerSnap.data()?.username || streamerWallet.substring(0,6);
                            
                             await runTransaction(db, async (t) => {
                                 const myUserRef = doc(db, "users", currentUser.walletAddress);
                                 const myDoc = await t.get(myUserRef);
                                 if (!myDoc.exists() || (myDoc.data().bitBalance || 0) < 100) {
                                      throw new Error("Insufficient balance during transaction."); 
                                 }
                                 t.update(myUserRef, { bitBalance: increment(-100) });
                                 // Asegurarse de que creatorRewardsBalance exista antes de incrementar
                                 const streamerData = streamerSnap.data() || {};
                                 const currentRewards = streamerData.creatorRewardsBalance || 0;
                                 t.update(streamerUserRef, { creatorRewardsBalance: currentRewards + 100 }); 
                                 
                                 t.set(subRef, { subscribedAt: serverTimestamp(), expiresAt: 'never' }); 
                             });
                             showToast(translations[currentLang].subscribed_to_user.replace('%s', streamerUsername));
                             updateButtonState(true); // Actualizar estado del botón
                         } catch (e) { 
                             console.error("Subscription transaction error: ", e.message || e); 
                             showToast(translations[currentLang].subscription_error + (e.message ? `: ${e.message.substring(0, 50)}` : ''), "error"); 
                             subBtn.disabled = false; // Re-habilitar en caso de error
                         } finally { 
                             if(loader) loader.classList.add('hidden'); 
                         }
                     };
                      subBtn.dataset.listenerAttached = 'true';
                 }
             }

             function setupVipEmojiPanel(streamerWallet) {
                 const openBtn = document.getElementById('open-vip-emojis');
                 const panel = document.getElementById('vip-emoji-panel');
                 const chatInput = document.getElementById('chat-input');
                  if (!openBtn || !panel || !chatInput || streamerWallet === currentUser?.walletAddress) { // No enviar VIP a sí mismo
                       if(openBtn) openBtn.style.display = 'none'; // Ocultar botón si es propio stream
                       return; 
                  } else {
                        if(openBtn) openBtn.style.display = 'block'; // Asegurar visibilidad
                  }

                 // Añadir listeners solo una vez
                 if (!openBtn.dataset.listenerAttached) {
                     openBtn.onclick = () => panel.classList.toggle('hidden');
                     openBtn.dataset.listenerAttached = 'true';
                 }
                
                 if (!panel.dataset.listenerAttached) {
                     panel.addEventListener('click', async (e) => {
                         const button = e.target.closest('.vip-emoji-btn');
                         if (button) {
                             if (!requireAuth()) return;
                             panel.classList.add('hidden');
                             const emoji = VIP_EMOJIS.find(em => em.id === button.dataset.emojiId);
                             if (!emoji) return; 

                             const text = chatInput.value.trim();
                             if (!text) {
                                  showToast(translations[currentLang].superchat_no_text, "info");
                                  return;
                             }
                             const currentBalance = currentUser.bitBalance || 0;
                             if (currentBalance < emoji.price) {
                                  showToast(translations[currentLang].insufficient_bits_emoji.replace('%p', emoji.price), "error");
                                  return;
                             }
                            
                             button.disabled = true; // Deshabilitar temporalmente el emoji
                             if(loader) loader.classList.remove('hidden');
                             try {
                                 await runTransaction(db, async (t) => {
                                     const myUserRef = doc(db, "users", currentUser.walletAddress);
                                     const streamerUserRef = doc(db, "users", streamerWallet);
                                     const myDoc = await t.get(myUserRef);
                                     if (!myDoc.exists() || (myDoc.data().bitBalance || 0) < emoji.price) {
                                          throw new Error("Insufficient balance during transaction.");
                                     }
                                     t.update(myUserRef, { bitBalance: increment(-emoji.price) });
                                     // Incrementar rewards del streamer
                                     const streamerSnap = await t.get(streamerUserRef);
                                     const currentRewards = streamerSnap.data()?.creatorRewardsBalance || 0;
                                     t.update(streamerUserRef, { creatorRewardsBalance: currentRewards + emoji.price });
                                 });
                                 await addDoc(collection(db, 'streams', streamerWallet, 'chat'), { 
                                     text, 
                                     userName: currentUser.username, 
                                     userWallet: currentUser.walletAddress, 
                                     userColor: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'), 
                                     createdAt: serverTimestamp(), 
                                     vipEmoji: { url: emoji.url, price: emoji.price } 
                                 });
                                 chatInput.value = ''; // Limpiar input después de enviar
                             } catch(err) { 
                                  console.error("Super Chat transaction error:", err.message || err); 
                                  showToast(translations[currentLang].superchat_error + (err.message ? `: ${err.message.substring(0, 50)}` : ''), "error"); 
                             } finally { 
                                 if(loader) loader.classList.add('hidden'); 
                                 button.disabled = false; // Rehabilitar emoji
                             }
                         }
                     });
                     panel.dataset.listenerAttached = 'true';
                 }
             }

             // --- Funciones de Streaming (WebRTC) ---
              let adInterval = null;
             function showAd() {
                 const adContainer = document.getElementById('ad-container'), adWarning = document.getElementById('ad-warning'), adSlot = document.getElementById('ad-slot');
                 if (!adContainer || !adWarning || !adSlot) return;
                 adSlot.innerHTML = ''; adContainer.style.display = 'flex'; let countdown = 5;
                 adWarning.textContent = translations[currentLang].ad_warning.replace('%s', countdown);
                 const countdownInterval = setInterval(() => {
                     countdown--; adWarning.textContent = translations[currentLang].ad_warning.replace('%s', countdown);
                     if (countdown <= 0) {
                         clearInterval(countdownInterval); adWarning.textContent = translations[currentLang].ad_playing;
                         const oldAdScript = document.getElementById('dynamic-ad-script'); if(oldAdScript) oldAdScript.remove();
                         const scriptEl = document.createElement('script'); scriptEl.id = 'dynamic-ad-script'; document.body.appendChild(scriptEl);
                         // Intentar cargar script de anuncio (puede ser bloqueado por adblockers)
                         try {
                              (function(s) { s.dataset.zone = '9912761'; s.src = 'https://groleegni.net/vignette.min.js'; })(scriptEl);
                         } catch (adError) {
                              console.warn("Ad script failed to load:", adError);
                         }
                         // Ocultar overlay después de un tiempo fijo, incluso si el anuncio no cargó
                         setTimeout(() => { adContainer.style.display = 'none'; adSlot.innerHTML = ''; const adScriptToRemove = document.getElementById('dynamic-ad-script'); if (adScriptToRemove) adScriptToRemove.remove(); }, 20000); 
                     }
                 }, 1000);
             }

             let localStream = null, peerConnections = {}, viewersUnsubscribe = null, streamTimerInterval = null, rewardInterval = null, unsubscribeStudioChat = null;
             const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

             async function attachStreamListeners() { // Mover antes de su uso
                 const selectCamBtn = document.getElementById('select-cam-btn');
                 const selectScreenBtn = document.getElementById('select-screen-btn');
                 const startStreamBtn = document.getElementById('start-stream-btn');
                 const stopStreamBtn = document.getElementById('stop-stream-btn');
                 const micSelect = document.getElementById('mic-select');

                 if (selectCamBtn) selectCamBtn.onclick = () => getMedia('camera');

                 if (selectScreenBtn) {
                      if (navigator.mediaDevices?.getDisplayMedia) { // Mejor verificación
                         selectScreenBtn.onclick = () => getMedia('screen');
                     } else { 
                         selectScreenBtn.disabled = true; 
                         selectScreenBtn.title = 'Screen sharing not supported by this browser.'; // Tooltip
                         selectScreenBtn.onclick = () => showToast('Screen sharing is not available.', 'info'); 
                     }
                 }
                if(startStreamBtn) startStreamBtn.onclick = startStream;
                if(stopStreamBtn) stopStreamBtn.onclick = stopStream;
                
                 if (micSelect) {
                     try {
                          // Pedir permiso primero para enumerar dispositivos con etiquetas
                          await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); 
                          const devices = await navigator.mediaDevices.enumerateDevices();
                          micSelect.innerHTML = ''; // Limpiar opciones previas
                          devices.filter(({ kind }) => kind === 'audioinput').forEach(({ deviceId, label }) => {
                              const option = document.createElement('option'); option.value = deviceId;
                              option.text = label || `${translations[currentLang].microphone} ${micSelect.options.length + 1}`;
                              micSelect.appendChild(option);
                          });
                          if (micSelect.options.length === 0) {
                              micSelect.innerHTML = '<option value="">No microphones found</option>';
                              micSelect.disabled = true;
                          }
                     } catch(e) { 
                          console.error("Error enumerating/accessing audio devices:", e); 
                          micSelect.innerHTML = '<option value="">Error accessing microphones</option>';
                          micSelect.disabled = true;
                          showToast("Could not access microphones.", "error");
                     }
                 }
             }

             async function getMedia(type) {
                  const localVideoPreview = document.getElementById('local-video-preview');
                  const startStreamBtn = document.getElementById('start-stream-btn');
                  const micSelect = document.getElementById('mic-select');
                  if(!localVideoPreview || !startStreamBtn || !micSelect) return; 

                 try {
                     if (localStream) localStream.getTracks().forEach(track => track.stop());
                     
                     const audioDeviceId = micSelect.value;
                     const audioConstraint = micSelect.disabled ? false : { deviceId: audioDeviceId ? {exact: audioDeviceId} : undefined }; // No pedir audio si no hay mic
                     let videoConstraint = true; // Por defecto pedir video

                     if (type === 'camera') {
                          localStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraint, audio: audioConstraint });
                     } else if (type === 'screen' && navigator.mediaDevices.getDisplayMedia) {
                          // Pedir video de pantalla y audio del sistema/micrófono por separado
                          const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }); // Preferir audio de pantalla si está disponible
                          let audioStream = null;
                          if (audioConstraint) { // Si hay un micrófono seleccionado, intentar obtenerlo
                               try {
                                    audioStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraint, video: false });
                               } catch (micError) {
                                    console.warn("Could not get microphone audio for screen share:", micError);
                                    // Continuar sin audio de micrófono si falla
                               }
                          }
                          
                          // Combinar pistas
                          localStream = new MediaStream();
                          screenStream.getVideoTracks().forEach(track => localStream.addTrack(track));
                          // Priorizar audio de pantalla si existe, si no, usar micrófono
                          if (screenStream.getAudioTracks().length > 0) {
                              screenStream.getAudioTracks().forEach(track => localStream.addTrack(track));
                              // Detener el stream de solo audio si se obtuvo por separado
                              if (audioStream) audioStream.getTracks().forEach(t => t.stop()); 
                          } else if (audioStream) {
                              audioStream.getAudioTracks().forEach(track => localStream.addTrack(track));
                          }
                                                    
                     } else {
                          throw new Error("Unsupported media type or browser capability");
                     }
                    
                     localVideoPreview.srcObject = localStream;
                     startStreamBtn.disabled = false; // Habilitar botón de inicio
                 } catch (error) { 
                     console.error(`Error getting ${type}:`, error); 
                     showToast(translations[currentLang].media_error + `: ${error.message}`, "error"); 
                     startStreamBtn.disabled = true; 
                     localStream = null; 
                     localVideoPreview.srcObject = null;
                 }
             }

             // ... (Resto de startStream, stopStream, joinStream con más checks y manejo de errores si es necesario) ...
             async function startStream() {
                 const streamTitleInput = document.getElementById('stream-title-input');
                 const streamCategorySelect = document.getElementById('stream-category-select');
                 const streamThumbnailInput = document.getElementById('stream-thumbnail-input');
                 const startStreamBtn = document.getElementById('start-stream-btn');
                 const stopStreamBtn = document.getElementById('stop-stream-btn');
                 const streamStatusText = document.getElementById('stream-status-text');
                  const studioChatMessages = document.getElementById('studio-chat-messages');

                 if (!localStream || !currentUser || !streamTitleInput || !streamCategorySelect || !streamThumbnailInput || !startStreamBtn || !stopStreamBtn || !streamStatusText || !studioChatMessages) {
                     showToast(translations[currentLang].no_video_source, "error");
                     console.error("Missing elements or stream/user data for startStream");
                     return; 
                 }

                 const streamRef = doc(db, 'streams', currentUser.walletAddress);
                if(loader) loader.classList.remove('hidden');
                 startStreamBtn.disabled = true; // Deshabilitar botón mientras inicia
                 
                 try {
                     await setDoc(streamRef, {
                         status: 'live', 
                         title: streamTitleInput.value || 'Live Stream', // Default title
                         category: streamCategorySelect.value || 'General', // Default category
                         thumbnailUrl: streamThumbnailInput.value || null, // Permitir nulo
                         streamerWallet: currentUser.walletAddress, 
                         streamerPic: currentUser.profilePicture, 
                         streamerUsername: currentUser.username, 
                         viewerCount: 0,
                         createdAt: serverTimestamp() // Añadir timestamp de creación
                     });

                     // Start viewer listener
                     viewersUnsubscribe = onSnapshot(collection(streamRef, 'viewers'), (snapshot) => {
                          if (!currentUser) return; 
                          const viewerCount = snapshot.size;
                          // Actualizar contador en Firestore (con manejo de errores)
                          updateDoc(doc(db, 'streams', currentUser.walletAddress), { viewerCount: viewerCount })
                             .catch(e => console.error("Error updating viewer count:", e)); 
                         
                         const studioViewerCount = document.getElementById('studio-viewer-count');
                         if(studioViewerCount) { 
                              studioViewerCount.innerHTML = `<i data-lucide="users" class="w-4 h-4"></i> ${viewerCount}`; 
                              lucide.createIcons(); 
                         }
                        
                         snapshot.docChanges().forEach(async (change) => {
                             const viewerUid = change.doc.id;
                             const viewerData = change.doc.data();
                             
                             if (change.type === 'added' && viewerData.offer) {
                                  // Crear nueva conexión para este viewer
                                  console.log(`Viewer ${viewerUid.substring(0,5)}... connected, creating PeerConnection.`);
                                  peerConnections[viewerUid] = new RTCPeerConnection(iceServers);
                                  
                                  // Añadir pistas del stream local
                                  localStream.getTracks().forEach(track => {
                                       try {
                                            peerConnections[viewerUid].addTrack(track, localStream);
                                       } catch (addTrackError) {
                                            console.error(`Error adding track (${track.kind}) for viewer ${viewerUid}:`, addTrackError);
                                       }
                                  });

                                  // Manejar candidatos ICE generados localmente
                                  peerConnections[viewerUid].onicecandidate = e => {
                                      if (e.candidate) {
                                           console.log(`Sending ICE candidate to viewer ${viewerUid.substring(0,5)}...`);
                                           addDoc(collection(change.doc.ref, 'iceCandidates'), e.candidate.toJSON())
                                             .catch(e => console.error("Error adding streamer ICE candidate for viewer:", viewerUid, e));
                                      }
                                  };
                                  
                                   // Manejar estado de conexión ICE
                                   peerConnections[viewerUid].oniceconnectionstatechange = () => {
                                        console.log(`ICE state change for viewer ${viewerUid.substring(0,5)}: ${peerConnections[viewerUid]?.iceConnectionState}`);
                                        // Podría añadirse lógica aquí si falla la conexión ICE
                                   };
                                  
                                  // Escuchar candidatos ICE del viewer
                                  const iceCandidateListener = onSnapshot(collection(change.doc.ref, 'iceCandidatesFromViewer'), 
                                       snap => snap.docChanges().forEach(c => {
                                            if (c.type === 'added') {
                                                 console.log(`Received ICE candidate from viewer ${viewerUid.substring(0,5)}...`);
                                                 peerConnections[viewerUid]?.addIceCandidate(new RTCIceCandidate(c.doc.data()))
                                                   .catch(e => console.warn("Error adding received ICE candidate:", e)); // Warn en lugar de error
                                            }
                                       }), 
                                       error => console.error("Error listening for viewer ICE candidates:", viewerUid, error)
                                  );
                                   // Guardar listener para limpiarlo después
                                   peerConnections[viewerUid].iceListenerUnsubscribe = iceCandidateListener;

                                  // Establecer descripción remota (oferta) y crear respuesta
                                  try {
                                       await peerConnections[viewerUid].setRemoteDescription(new RTCSessionDescription(viewerData.offer));
                                       const answer = await peerConnections[viewerUid].createAnswer();
                                       await peerConnections[viewerUid].setLocalDescription(answer);
                                       console.log(`Sending answer to viewer ${viewerUid.substring(0,5)}...`);
                                       await updateDoc(change.doc.ref, { answer });
                                  } catch (rtcError) {
                                       console.error(`WebRTC setup error for viewer ${viewerUid}:`, rtcError);
                                       if (peerConnections[viewerUid]) { 
                                            peerConnections[viewerUid].iceListenerUnsubscribe?.(); // Limpiar listener ICE
                                            peerConnections[viewerUid].close(); 
                                            delete peerConnections[viewerUid]; 
                                       } 
                                  }
                             } else if (change.type === 'removed') {
                                   console.log(`Viewer ${viewerUid.substring(0,5)}... disconnected.`);
                                   if (peerConnections[viewerUid]) {
                                        peerConnections[viewerUid].iceListenerUnsubscribe?.(); // Limpiar listener ICE
                                        peerConnections[viewerUid].close();
                                        delete peerConnections[viewerUid];
                                   }
                             }
                         });
                     }, error => console.error("Error listening to viewers collection:", error));

                     // Start chat listener
                     const chatRef = collection(streamRef, 'chat');
                     unsubscribeStudioChat = onSnapshot(query(chatRef, orderBy("createdAt", "desc"), limit(50)), (snapshot) => {
                         if (!studioChatMessages) return;
                          // Mejorar rendimiento: añadir solo los nuevos mensajes
                          let newMessagesHtml = "";
                          snapshot.docChanges().reverse().forEach(change => {
                              if (change.type === "added") {
                                  const msg = change.doc.data();
                                  let msgHtml = '';
                                  if (msg.vipEmoji) {
                                      msgHtml = `<div class="super-chat text-xs"><div class="flex items-center gap-1 mb-1"><img src="${msg.vipEmoji.url}" class="w-6 h-6"><div class="font-bold">${msg.userName || 'User'} ${translations[currentLang].sent} ${msg.vipEmoji.price} BIT</div></div><p>${msg.text || ''}</p></div>`;
                                  } else { 
                                      msgHtml = `<div class="text-xs p-1"><strong style="color: ${msg.userColor || '#FFF'}">${msg.userName || 'User'}:</strong> ${msg.text || ''}</div>`; 
                                  }
                                  newMessagesHtml += msgHtml;
                              }
                          });
                          if (newMessagesHtml) {
                               studioChatMessages.innerHTML += newMessagesHtml;
                               studioChatMessages.scrollTop = studioChatMessages.scrollHeight; // Scroll to bottom
                          }
                     }, error => console.error("Error listening to studio chat:", error));

                     streamStatusText.innerHTML = `<span class="text-red-500 font-bold flex items-center gap-2"><div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>LIVE</span>`;
                     // startStreamBtn ya está deshabilitado
                     stopStreamBtn.disabled = false; // Habilitar botón de detener
                    
                     // Start timer
                     let startTime = Date.now();
                     const timerEl = document.getElementById('stream-timer');
                     if (timerEl) {
                         if (streamTimerInterval) clearInterval(streamTimerInterval); // Limpiar intervalo previo si existe
                         streamTimerInterval = setInterval(() => { 
                             const e=Date.now()-startTime,s=Math.floor(e/1e3%60).toString().padStart(2,'0'),m=Math.floor(e/6e4%60).toString().padStart(2,'0'),h=Math.floor(e/36e5).toString().padStart(2,'0'); 
                             timerEl.textContent=`${h}:${m}:${s}`;
                         }, 1000);
                     }

                     // Start rewards interval
                     let lastRewardTimeInMinutes = 0;
                     if (rewardInterval) clearInterval(rewardInterval); // Limpiar intervalo previo
                     rewardInterval = setInterval(async () => {
                          if (!currentUser) { // Detener si el usuario se desloguea
                               clearInterval(rewardInterval);
                               return;
                          }
                         const currentMinutes = Math.floor((Date.now() - startTime) / 60000);
                         if (currentMinutes >= lastRewardTimeInMinutes + REWARD_INTERVAL_MINUTES) {
                             lastRewardTimeInMinutes = currentMinutes; // Actualizar al minuto actual para evitar saltos
                             try {
                                 await updateDoc(doc(db, "users", currentUser.walletAddress), { creatorRewardsBalance: increment(REWARD_AMOUNT) });
                                 showToast(translations[currentLang].reward_notification.replace('%a', REWARD_AMOUNT.toLocaleString()).replace('%m', lastRewardTimeInMinutes), "info");
                             } catch (rewardError) {
                                  console.error("Error updating creator rewards:", rewardError);
                                  // Considerar no mostrar toast si falla
                             }
                         }
                     }, 30000); // Chequear cada 30 segundos

                     // Start ads interval
                     if(adInterval) clearInterval(adInterval);
                     adInterval = setInterval(showAd, 120000); // 2 minutos

                     showToast(translations[currentLang].stream_started);
                 } catch (error) { 
                     console.error("Error starting stream:", error); 
                     showToast(translations[currentLang].stream_start_error + `: ${error.message}`, "error"); 
                     stopStream(); // Attempt cleanup on error
                     startStreamBtn.disabled = false; // Rehabilitar botón si falla el inicio
                 } finally { 
                    if(loader) loader.classList.add('hidden'); 
                 }
             }

              async function stopStream() {
                 console.log("Stopping stream...");
                 // Deshabilitar botón de detener inmediatamente
                 const stopBtn = document.getElementById('stop-stream-btn');
                 if(stopBtn) stopBtn.disabled = true;

                 // Clear intervals
                 if (streamTimerInterval) clearInterval(streamTimerInterval); 
                 if (rewardInterval) clearInterval(rewardInterval); 
                 if (adInterval) clearInterval(adInterval); 
                 streamTimerInterval=null; rewardInterval=null; adInterval=null;

                 // Stop media tracks
                 if (localStream) {
                     localStream.getTracks().forEach(track => track.stop());
                     localStream = null;
                 }

                 // Unsubscribe Firestore listeners
                 if (viewersUnsubscribe) viewersUnsubscribe(); 
                 if (unsubscribeStudioChat) unsubscribeStudioChat(); 
                 viewersUnsubscribe=null; unsubscribeStudioChat=null;

                 // Close peer connections and clean up listeners
                 Object.entries(peerConnections).forEach(([viewerUid, pc]) => {
                      pc.iceListenerUnsubscribe?.(); // Limpiar listener ICE específico
                      pc.close();
                      console.log(`Closed PeerConnection for viewer ${viewerUid.substring(0,5)}...`);
                 });
                 peerConnections = {};

                 // Update UI elements safely (si estamos en la página de studio)
                 const studioUI = document.getElementById('studio-content'); // O el contenedor padre relevante
                 if(studioUI && document.querySelector('#start-stream-btn')) { // Verificar si estamos en la vista de stream
                     const statusText = studioUI.querySelector('#stream-status-text'); 
                     if (statusText) statusText.textContent = translations[currentLang].preview;
                    
                     const timerEl = studioUI.querySelector('#stream-timer'); 
                     if (timerEl) timerEl.textContent = '';
                    
                     const viewerCountEl = studioUI.querySelector('#studio-viewer-count'); 
                     if (viewerCountEl) viewerCountEl.innerHTML = '';
                    
                     const startBtn = studioUI.querySelector('#start-stream-btn');
                     // Mantener deshabilitado hasta que se seleccione nueva media
                     if (startBtn) startBtn.disabled = true; 

                     // stopBtn ya está deshabilitado

                     const videoPreview = studioUI.querySelector('#local-video-preview'); 
                     if(videoPreview) videoPreview.srcObject = null;
                 }

                 // Delete stream data from Firestore only if user is logged in
                 if (currentUser?.walletAddress) {
                     const streamerWallet = currentUser.walletAddress; // Guardar wallet antes de posible logout
                     const streamRef = doc(db, 'streams', streamerWallet);
                     try {
                         // Intentar borrar subcolecciones (puede fallar si ya no existen)
                         for(const collName of ['viewers', 'chat']) { // Añadir 'iceCandidates' etc. si es necesario
                             try {
                                  const collRef = collection(streamRef, collName);
                                  const snapshot = await getDocs(query(collRef, limit(500))); // Limitar batch size
                                  if(!snapshot.empty) { 
                                      const batch = writeBatch(db); 
                                      snapshot.forEach(subDoc => batch.delete(subDoc.ref)); 
                                      await batch.commit(); 
                                      console.log(`Deleted batch from subcollection: ${collName}`);
                                      // Podría necesitar repetirse si hay más de 500 documentos
                                  }
                             } catch (subDelError) {
                                  console.warn(`Could not fully delete subcollection ${collName}:`, subDelError);
                             }
                         }
                         // Borrar documento principal
                         await deleteDoc(streamRef);
                         console.log("Stream document deleted.");
                     } catch(error) { 
                         console.error("Error cleaning up stream Firestore data:", error); 
                         // Intentar borrar doc principal de nuevo si falla
                         await deleteDoc(streamRef).catch(e => console.error("Failed to delete main stream doc after error:", e)); 
                     }
                 } else {
                      console.warn("Stop stream called but no current user found.");
                 }

                 showToast(translations[currentLang].stream_stopped);
             }

             async function joinStream(streamerWallet) {
                 const remoteVideo = document.getElementById('remote-video');
                 const videoOverlay = document.getElementById('video-overlay');
                  if (!remoteVideo || !videoOverlay) {
                      console.error("Video elements not found for joinStream");
                      showToast("Error setting up video player.", "error");
                      renderExplorePage(); // Volver si falta UI
                      return;
                  }
                  // Asegurar que WebRTC es compatible
                  if (typeof RTCPeerConnection === 'undefined') {
                       videoOverlay.textContent = "WebRTC not supported by your browser.";
                       showToast("Streaming not supported by your browser.", "error");
                       return;
                  }

                 // Limpiar conexión previa si existe
                 if (viewerPeerConnection) {
                     try { viewerPeerConnection.close(); } catch (e) {}
                     viewerPeerConnection = null;
                 }
                 // Limpiar intervalo de anuncios previo
                 if(adInterval) clearInterval(adInterval);
                 adInterval = null;

                 videoOverlay.textContent = translations[currentLang].connecting_stream;
                 videoOverlay.style.display = 'flex';
                 remoteVideo.classList.add('opacity-0');
                 remoteVideo.classList.remove('opacity-100');
                 remoteVideo.srcObject = null; // Limpiar video previo

                 viewerPeerConnection = new RTCPeerConnection(iceServers);
                
                 const viewerId = auth.currentUser?.uid || `guest_${Date.now()}_${Math.random().toString(36).substring(2)}`;
                 const viewerRef = doc(db, 'streams', streamerWallet, 'viewers', viewerId);
                 const iceCandidateBuffer = []; // Buffer para candidatos ICE

                 // Listener para estado de conexión ICE
                 viewerPeerConnection.oniceconnectionstatechange = () => {
                     const state = viewerPeerConnection?.iceConnectionState; // Verificar si pc existe
                     console.log(`Viewer ICE State: ${state}`);
                     if (!videoOverlay) return; // Verificar si overlay existe

                     switch(state) {
                          case 'checking':
                               videoOverlay.textContent = 'Connecting...';
                               break;
                          case 'connected':
                          case 'completed':
                               videoOverlay.style.display = 'none'; 
                               remoteVideo.classList.remove('opacity-0'); 
                               remoteVideo.classList.add('opacity-100');
                               // Iniciar anuncios solo al conectar
                               if(!adInterval) { // Evitar múltiples intervalos
                                    adInterval = setInterval(showAd, 120000); 
                                    console.log("Ad interval started.");
                               }
                               break;
                          case 'disconnected':
                               videoOverlay.textContent = 'Reconnecting...';
                               videoOverlay.style.display = 'flex';
                               break;
                          case 'failed':
                               videoOverlay.textContent = 'Connection failed.';
                               videoOverlay.style.display = 'flex';
                               cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer); // Limpiar en fallo
                               break;
                          case 'closed':
                               videoOverlay.textContent = 'Connection closed.';
                               videoOverlay.style.display = 'flex';
                               // Ya debería haberse limpiado, pero asegurar
                               cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer); 
                               break;
                          default:
                               videoOverlay.textContent = `Status: ${state}`;
                     }
                 };

                 // Listener para recibir pistas de video/audio
                 viewerPeerConnection.ontrack = e => { 
                     console.log("Track received:", e.track.kind);
                     if (remoteVideo && e.streams && e.streams[0]) {
                         if (remoteVideo.srcObject !== e.streams[0]) {
                              remoteVideo.srcObject = e.streams[0]; 
                              console.log("Remote stream assigned to video element.");
                         }
                     } else {
                          console.warn("Stream not found on track event or video element missing.");
                     }
                 };

                 // Listener para generar candidatos ICE locales
                 viewerPeerConnection.onicecandidate = e => {
                     if (e.candidate) {
                          console.log("Viewer sending ICE candidate...");
                          // Enviar candidato a Firestore (subcolección del viewer)
                          addDoc(collection(viewerRef, 'iceCandidatesFromViewer'), e.candidate.toJSON())
                            .catch(e => console.error("Error sending viewer ICE candidate:", e));
                     }
                 };
                
                 // Listener para candidatos ICE del streamer (declarar antes de usar en cleanup)
                 let unsubscribeIce = null;
                 unsubscribeIce = onSnapshot(collection(viewerRef, 'iceCandidates'), 
                     s => s.docChanges().forEach(change => {
                         if (change.type === 'added' && viewerPeerConnection) { // Verificar si pc existe
                             const candidate = new RTCIceCandidate(change.doc.data());
                             console.log("Viewer received ICE candidate...");
                             if (viewerPeerConnection.currentRemoteDescription) {
                                 viewerPeerConnection.addIceCandidate(candidate).catch(e => console.warn("Error adding received ICE candidate:", e));
                             } else {
                                 console.log("Buffering ICE candidate.");
                                 iceCandidateBuffer.push(candidate); // Guardar si la descripción remota aún no está lista
                             }
                         }
                     }),
                     error => console.error("Error listening for streamer ICE candidates:", error)
                 );

                 // Listener para la respuesta del streamer (declarar antes de usar en cleanup)
                 let unsubscribeAnswer = null;

                 try {
                     console.log("Creating offer...");
                     const offer = await viewerPeerConnection.createOffer({offerToReceiveVideo: true, offerToReceiveAudio: true});
                     await viewerPeerConnection.setLocalDescription(offer);
                     console.log("Offer created and set, sending to Firestore...");
                     
                      // Crear/Setear documento del viewer con la oferta
                     await setDoc(viewerRef, { offer: viewerPeerConnection.localDescription.toJSON(), joinedAt: serverTimestamp() }); 
                    
                     // Listener para la respuesta
                     unsubscribeAnswer = onSnapshot(viewerRef, async (docSnap) => {
                         if (!viewerPeerConnection) return; // Salir si la conexión ya se cerró

                         const data = docSnap.data();
                         if (data?.answer && !viewerPeerConnection.currentRemoteDescription) { // Verificar si hay respuesta y aún no se ha establecido
                              console.log("Answer received, setting remote description...");
                              try {
                                 await viewerPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                                 console.log("Remote description set. Adding buffered ICE candidates...");
                                 // Añadir candidatos ICE que llegaron antes
                                 while (iceCandidateBuffer.length > 0) {
                                     const candidate = iceCandidateBuffer.shift();
                                     console.log("Adding buffered ICE candidate...");
                                     await viewerPeerConnection.addIceCandidate(candidate);
                                 }
                              } catch (e) {
                                  console.error("Error setting remote description or adding buffered candidates:", e);
                                  if (videoOverlay) videoOverlay.textContent = "Error connecting stream.";
                                  cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer); // Limpiar en error
                              }
                         } else if (!data) {
                             // El documento del viewer fue eliminado (streamer cerró o hubo error)
                             console.warn("Viewer document deleted or doesn't exist.");
                             if (videoOverlay) videoOverlay.textContent = "Stream connection lost.";
                             cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer);
                         }
                     }, error => {
                          console.error("Error listening for answer:", error);
                          if (videoOverlay) videoOverlay.textContent = "Error listening for stream data.";
                          cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer);
                     });

                 } catch (error) {
                     console.error("Error joining stream (creating offer/setting doc):", error);
                     if (videoOverlay) videoOverlay.textContent = "Failed to join stream.";
                     cleanupConnection(viewerRef, unsubscribeIce, unsubscribeAnswer); // Limpiar en error inicial
                 }
             }
             
             // Función de limpieza centralizada
             function cleanupConnection(viewerDocRef, iceListener, answerListener) {
                  console.log("Cleaning up viewer connection...");
                  if (iceListener) iceListener();
                  if (answerListener) answerListener();
                  if (viewerPeerConnection) { 
                       try { viewerPeerConnection.close(); } catch(e){}
                       viewerPeerConnection = null; 
                  }
                  if(adInterval) {
                       clearInterval(adInterval); 
                       adInterval = null;
                       console.log("Ad interval stopped.");
                  }
                  // Borrar documento del viewer en Firestore (si existe la referencia)
                  if (viewerDocRef) {
                       deleteDoc(viewerDocRef).catch(e => console.warn("Error deleting viewer doc on cleanup:", e));
                  }
                  // Asegurar que UI refleje desconexión si aún no lo hace
                  const videoOverlay = document.getElementById('video-overlay');
                  if (videoOverlay && videoOverlay.style.display === 'none') {
                       videoOverlay.textContent = 'Connection closed.';
                       videoOverlay.style.display = 'flex';
                  }
             }

             // Limpiar al descargar la página (mejorado)
             window.addEventListener('pagehide', () => { 
                  if (Object.keys(peerConnections).length > 0) stopStream(); // Si es streamer
                  if (viewerPeerConnection) { // Si es viewer
                       // Los listeners deberían limpiarse con la referencia del doc, pero asegurar
                       cleanupConnection(
                            doc(db, 'streams', 'someStreamer', 'viewers', auth.currentUser?.uid || 'guest'), // Referencia dummy si no la tenemos
                            null, // No podemos pasar los listeners directamente aquí
                            null
                       ); 
                  }
             });
             window.addEventListener('beforeunload', () => { // Para algunos casos donde pagehide no funciona
                   if (Object.keys(peerConnections).length > 0) { stopStream(); }
                   if (viewerPeerConnection) { cleanupConnection(null, null, null); }
             });

            // --- INICIALIZACIÓN FINAL --- (dentro de DOMContentLoaded)
            renderExplorePage(); // Renderizar la página inicial por defecto
            setupNavigation(); // Configurar la navegación una sola vez

        }); // --- FIN DEL WRAPPER DOMContentLoaded ---
    </script>
</body>
</html>

